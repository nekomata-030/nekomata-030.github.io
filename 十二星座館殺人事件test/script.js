
document.addEventListener('DOMContentLoaded', () => {
    const npcs = [{"id":"npc-1763872097772","name":"â™“ è‰¾å¾·é‡Œå…‹ï¼Žå¯ç¾…æº«ï¼Žæ´¾è¥¿æ–¯","shortDescription":"","description":"","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"Default","src":"images/npc_npc_0_0_1.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[{"label":"å±žæ€§1","value":""},{"label":"å±žæ€§2","value":""}]},"initiative":"","commands":""},{"id":"npc-1763872771483","name":"â™Š å¸Œæ¡‘åˆ©ï¼Žä½©çˆ¾è¥¿è«¾é›·å¾·ï¼Žæ ¼æ•å°¼","shortDescription":"ã€é›™å­åº§ã€‘","description":"ã€é›™å­åº§ã€‘\nSisanda Persinored Geminiï½œå¸Œæ¡‘åˆ©ï¼Žä½©çˆ¾è¥¿è«¾é›·å¾·ï¼Žæ ¼æ•å°¼\nSIZï¼š18ï½œAPPï¼š10ï½œæ€§åˆ¥ï¼šï¼Ÿï¼Ÿï½œå¹´é½¡ï¼šï¼Ÿï¼Ÿ\nåœ‹ç±ï¼šï¼Ÿï¼Ÿï¼Ÿ\n\nã€Œè–èª•è€äººæ­¡æ¨‚é€ï¼ï¼å“¦ï¼Ÿä½ èªªç¦®ç‰©åœ¨å“ªï¼Ÿä½ â˜†å°±æ˜¯æˆ‘çš„ç¦®ç‰©~ï¼ã€\nã€Œä½ æœ‰ä»€éº¼ç…©æƒ±å—Žï¼å¯ä»¥éš¨æ™‚ä¾†æ‰¾æˆ‘å‚¾è¨´å“¦ï¼Œæˆ‘çµ•å°æ˜¯ä½ çš„éˆé­‚å¤¥ä¼´â™¡~ã€\n\nã€Œå¥½ç´¯~æˆ‘èµ°ä¸å‹•äº†å•¦~ï¼èƒŒ~æˆ‘~~ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"0_004_03","src":"images/npc_npc_1_0_7.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763872794219","name":"â™ å·´å¸­çˆ¾ãƒ»è·¯æ˜“æ–¯ãƒ»ç¶­çˆ¾æžœ","shortDescription":"","description":"","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"1","src":"images/npc_npc_2_0_9.jpeg"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763872819395","name":"â™Œ å“ˆç‰¹å¨çˆ¾ãƒ»åˆ©å¥§","shortDescription":"","description":"","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"IMG_1026","src":"images/npc_npc_3_0_5.jpeg"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873342666","name":"â™‘ æ ¼é‡ŒèŠ¬ï¼Žéœç€ï¼Žä¿®ç¾…","shortDescription":"ã€æ‘©èŽåº§ã€‘","description":"ã€æ‘©èŽåº§ã€‘\nGriffin Hopper Capricornusï½œæ ¼é‡ŒèŠ¬.éœç€.ä¿®ç¾…\nSIZï¼š14ï½œAPPï¼š17ï½œæ€§åˆ¥ï¼šç”·ï½œå¹´é½¡ï¼š16\nåœ‹ç±ï¼šè˜‡æ ¼è˜­\n\nã€Œå—¯ï¼Ÿä½ èªªèƒŒå¾Œçš„åŠï¼Ÿå¾ˆé…·æ˜¯å§ï¼Œæƒ³è¦æ‹¿çœ‹çœ‹å—Žï¼Ÿã€\nã€Œâ€¦â€¦å“¼å“¼ï¼Œæ˜¯å‡åŠï¼Œåªæ˜¯å› ç‚ºå¾ˆé…·å°±èƒŒåœ¨èº«ä¸Šäº†ã€‚ã€\n\nã€Œè‹¥æ˜¯ä¸ä»‹æ„ï¼Œè«‹è®“æˆ‘èªªå€‹æ•…äº‹å§ã€‚ä¸€ä½å‚³æ•™å£«ï¼Œç‚ºä»€éº¼æœƒæˆç‚ºå¥³çŽ‹è¼¦ä¸‹çš„é¨Žå£«ï¼Ÿã€\nã€Œå› ç‚ºæˆ‘å–œæ­¡å°±ç•¶äº†ã€‚ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"F9CC42D5-2CA0-49A2-975D-F3F1AC56D802","src":"images/npc_npc_4_0_0.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873369915","name":"â™’ é›·è²çˆ¾ï¼Žé˜¿å¥Žé‡ŒåŽ„æ–¯","shortDescription":"ã€æ°´ç“¶åº§ã€‘","description":"ã€æ°´ç“¶åº§ã€‘\nRebel Aquariusï½œé›·è²çˆ¾ï¼Žé˜¿å¥Žé‡ŒåŽ„æ–¯\nSIZï¼š11ï½œAPPï¼š10ï½œæ€§åˆ¥ï¼šç”·æ€§ï¼Œä¸é€™æ˜¯èªçœŸçš„ï¼Œç‚ºä»€éº¼å¤§å®¶å°æˆ‘çš„ç¬¬ä¸€å°è±¡ç¶“å¸¸æ˜¯å¥³æ€§å‘¢ï¼Œæˆ‘å°è‡ªå·±çš„å¤–è¡¨é‚„æ˜¯æŒºæœ‰è‡ªä¿¡çš„è€¶ï¼Ÿï¼ˆå˜€å’•ï¼‰é›£é“çœŸçš„é‚£éº¼ä¸åƒç”·ç”Ÿå—Ž......å•Šå•Šï¼Œç¸½è€Œè¨€ä¹‹ï¼Œæˆ‘çœŸçš„æ˜¯å¯¦å¯¦åœ¨åœ¨å¾žè£¡åˆ°å¤–ç´”å¤©ç„¶100%ç„¡äººå·¥æ·»åŠ ç‰©çš„ ç”· å­© å­ ï¼ŒçœŸçš„ï¼å•Šï¼Œè¦çœ‹æˆ‘çš„åç‰‡å—Žï¼Ÿçµ¦ä½ ä¸€å¼µâ™ª  å¥½äº†ï¼Œçœ‹ï¼ä¸Šé¢å¯«å¾—å¾ˆæ¸…æ¥šï¼Œå°å§ï¼Ÿæˆ‘æ˜¯ç”·æ€§ï¼ç”·ï¼æ€§ï¼ï½œå¹´é½¡ï¼šåµæŽ¢\nåœ‹ç±ï¼šå¤§æ¦‚21æ­²å§\nâ €\nã€Œå•Šï¼ï¼ï¼å¹¸æœƒï¼Œæˆ‘å«åšé›·è²çˆ¾ï¼æ˜¯ä¸€åè²¨çœŸåƒ¹å¯¦çš„åµæŽ¢å–”ã€‚ã€\n\nã€Œæžœç„¶é‚„æ˜¯åƒå¥³ç”Ÿï¼Ÿèª’èª’ï¼ŒçœŸæ˜¯å›°æ“¾......ã€\n\nã€Œç¸½è€Œè¨€ä¹‹ï¼Œä¸ç®¡æ˜¯äº‹ä»¶é‚„æ˜¯ä»€éº¼ï¼Œæ—¢ç„¶æœ‰è¾¦æ³•ç™¼ç”Ÿï¼Œé‚£å°±æ‡‰è©²æœƒæœ‰è¾¦æ³•è§£æ±ºçš„å§ï¼...å¤§æ¦‚ï¼ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0009","src":"images/npc_npc_5_0_2.png"},{"name":"æ’åœ–_0010","src":"images/npc_npc_5_1_4.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873407706","name":"â™‰ ç¦å¡ãƒ»å¡”ç¾…çµ²","shortDescription":"ã€é‡‘ç‰›åº§ã€‘","description":"ã€é‡‘ç‰›åº§ã€‘\nChicaãƒ»Taurusï½œç¦å¡ãƒ»å¡”ç¾…çµ²\nSIZï¼š14ï½œAPPï¼š11ï½œæ€§åˆ¥ï¼šç”·ï½œå¹´é½¡ï¼š18\nåœ‹ç±ï¼šæ—¥è‹±æ··è¡€ï¼Œå‡ºç”Ÿåœ°ç‚ºè‹±åœ‹\nã€Œæˆ‘çš„æƒ³æ³•å—Žï¼Ÿæœ‰äº›äº‹æƒ…é‚„æ˜¯å…ˆä¸è¦è¼•æ˜“ä¸‹å®šè«–æ¯”è¼ƒå¥½å‘¢ï¼Ÿã€\nã€Œé€™å€‹å˜›â€¦â€¦æˆ‘æƒ³å…ˆè½è½å…ˆç”Ÿ/å°å§æ‚¨çš„é«˜è¦‹ï¼Ÿã€\n\nã€Œ1+1å°±ç®—ç­‰æ–¼5ï¼Œæˆ‘ä¹Ÿæœƒè¦ºå¾—æ‚¨èªªå¾—éƒ½å°ï¼Œæˆ–è¨±è©²èªªå„˜ç®¡ç¾å ´å¤šéº¼åœ°ä¸åˆç†ï¼Œçœ¼ä¸‹è­‰æ“šå°±æ˜¯æœ‰å¦‚æ­¤æ•ˆåŠ›ï¼Ÿã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0007","src":"images/npc_npc_6_0_11.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873428482","name":"â™Ž ä»¥æ–¯å¸–ï¼ŽAï¼Žé‡ŒæŸæ‹‰","shortDescription":"ã€å¤©ç§¤åº§ã€‘","description":"ã€å¤©ç§¤åº§ã€‘\nEsther A. Libraï½œä»¥æ–¯å¸–ï¼ŽAï¼Žé‡ŒæŸæ‹‰\nSIZï¼š12ï½œAPPï¼š10ï½œæ€§åˆ¥ï¼šï¼Ÿï½œå¹´é½¡ï¼šï¼Ÿ\nåœ‹ç±ï¼šå¸Œè‡˜\n\nã€Œä¾†å§ï¼Œå¦‚ä»Šæ­£æ˜¯æŠ‰æ“‡ä¹‹æ™‚ï¼Œè«‹å‘Šè¨´æˆ‘æ‚¨çš„ç­”æ¡ˆã€‚ã€\nã€Œâ€¦â€¦æ˜¯é€™æ¨£å‘€ï¼Œæˆ‘æ˜Žç™½äº†ã€‚ã€\n\nã€Œå‘µå‘µï¼Œæ˜¯å¦ç‚ºæ­£ç¢ºçš„é¸æ“‡ï¼Œæ‚¨ä¸è©²æ˜¯æœ€æ¸…æ¥šçš„äººå—Žï¼Ÿã€\nã€Œè«‹åˆ¥å¤ªéŽä¾è³´è¦–è¦ºï¼Œå³ä½¿æ˜¯é›™çœ¼ä¹Ÿæœƒæ¬ºé¨™è‡ªå·±çš„å“¦ã€‚ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0006","src":"images/npc_a_0_3.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873435522","name":"â™ˆ èŽ«å¸Œï¼Žé˜¿é‡Œæ–¯","shortDescription":"ã€ç‰¡ç¾Šåº§ã€‘","description":"ã€ç‰¡ç¾Šåº§ã€‘\n \nMoxie Ariesï½œèŽ«å¸Œï¼Žé˜¿é‡Œæ–¯\nSIZï¼š7ï½œAPPï¼š15ï½œFEMALEï½œAGEï¼š27\nåœ‹ç±ï¼šè‹±åœ‹\n\nã€Œå˜¿ï¼Œä½ èªªä»€éº¼â€”â€”ï¼Ÿæˆ‘åªæ˜¯é•·å¾—æ¯”è¼ƒå°ä¸€é»žå•¦ï½žä¸éŽè…¦è¢‹å¯ä¸€é»žéƒ½ä¸å°å–”â™¥ã€\n\nã€Œé€™ä¸–ç•Œä¸Šæœ‰å¤ªå¤šåŒ…è£å¾—éŽè¯éº—è»Ÿç¶¿çš„ç³–è¡£äº†ï¼Œæœ‰æ™‚å€™å•Šï¼Œè¦æ‹†ç©¿ä¸€å€‹è¬Šï¼Œå°±å¾—å…ˆå‡è£ä½ ç›¸ä¿¡å®ƒã€‚ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0005","src":"images/npc_npc_8_0_12.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873444018","name":"â™‹ è·¯è¥¿å®‰ãƒ»åŽç‘Ÿ","shortDescription":"ã€å·¨èŸ¹åº§ã€‘","description":"ã€å·¨èŸ¹åº§ã€‘\nLucien Cancerï½œè·¯è¥¿å®‰ãƒ»åŽç‘Ÿ\nSIZï¼š14ï½œAPPï¼š12ï½œMALEï½œAGEï¼š32\nåœ‹ç±ï¼šè·è˜­\n\nã€Œå—¯ï¼Ÿå«æˆ‘è·¯æ–¯(Luce)å°±å¯ä»¥äº†ã€‚å¦‚æžœéœ€è¦äººè¨˜éŒ„é»žæ±è¥¿ã€è™•ç†äº›ç¾å ´çš„å°äº‹ï¼Œæˆ‘æ‡‰è©²èƒ½å¹«å¾—ä¸Šå¿™ã€‚ã€\n\nã€Œå¦å¤–é‚„è«‹æ³¨æ„èª¿æŸ¥æ™‚ä¸è¦å—å‚·......å„ä½éƒ½æ˜¯ä¸€æµåµæŽ¢ï¼Œæƒ³å¿…æ²’å•é¡Œçš„å§ã€‚ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0004","src":"images/npc_npc_9_0_10.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873452322","name":"â™ å‡¡å¦®èŽŽï¼Žå¤æ´›ç‰¹ï¼Žç‘ŸåŸºå¡”ç‘žæ–¯","shortDescription":"ã€å°„æ‰‹åº§ã€‘","description":"ã€å°„æ‰‹åº§ã€‘\nVanessa Charlotte Sagittariusï¸±å‡¡å¦®èŽŽï¼Žå¤æ´›ç‰¹ï¼Žç‘ŸåŸºå¡”ç‘žæ–¯\nÒ“á´‡á´á´€ÊŸá´‡ã€€sÉªá´¢ Â¹Â²ã€€á´€á´˜á´˜ Â¹Â¹ã€€á´€É¢á´‡ Â³Â³ã€€Ê™Ê€Éªá´›s\n\n\nã€ŒåµæŽ¢æ˜¯å®£ä½ˆçœŸç›¸çš„è§’è‰²ï¼Œä½†æœ‰èª°èƒ½ä¾†å®šå¥ªé‚£å€‹çœŸç›¸æ­£ç¢ºèˆ‡å¦ï¼Ÿã€\n\nã€Œä¸æœƒæœ‰é‚£æ¨£çš„äººå§ã€‚ã€\nã€Œå³ä½¿å¦‚æ­¤ï¼ŒåµæŽ¢çš„è·è²¬ä»ç„¶æ˜¯æ™‚åˆ»å¯©è¦–ã€æ™‚åˆ»ä¿®æ­£â€”â€”ã€\n\nã€Œç„¶å¾Œï¼Œç”¨ç›¡å…¨åŠ›æ‰¾å‡ºæ­£ç¢ºçš„çœŸç›¸ã€‚ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0002","src":"images/npc_npc_10_0_6.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""},{"id":"npc-1763873461906","name":"â™ è–‡è–‡å®‰ï¼Žç‘ªèŽ‰æˆˆå¾·ï¼Žæ–¯ç§‘çš®æ–¯","shortDescription":"ã€å¤©è åº§ã€‘","description":"ã€å¤©è åº§ã€‘\nVivienne Marigold Scorpiusï½œè–‡è–‡å®‰ï¼Žç‘ªèŽ‰æˆˆå¾·ï¼Žæ–¯ç§‘çš®æ–¯\nSIZï¼š13ï½œAPPï¼š12ï½œFEMALEï½œAGEï¼šå¹´é½¡å¯æ˜¯å¥³äººçš„ç§˜å¯†\nåœ‹ç±ï¼šè‹±åœ‹\n\nã€Œå‘½é‹çš„ä½Žèªžï¼Œæˆ‘èƒ½è½è¦‹ï¼›è—¥è‰çš„æ€§è³ªï¼Œæˆ‘èƒ½è§£æžï¼›è¿·æ¡ˆçš„ç ´å£ï¼Œæˆ‘èƒ½æ‰¾åˆ°â€”â€”æœ‰åƒ¹å€¼çš„å§”è¨—ï¼Œè‡ªç„¶å€¼å¾—æˆ‘å‡ºæ‰‹ã€‚ã€\n\nã€Œç„¡è«–æ˜¯ç™‚å‚·ã€å•é‹ï¼Œé‚„æ˜¯éœ€è¦ä¸€å€‹èƒ½çœ‹é€ç¾å ´çš„äººï¼Œä½ éƒ½æ‰¾å°äººäº†ã€‚ã€","borderColor":"#cccccc","bubbleColor":"#f7f7f7","images":[{"name":"æ’åœ–_0001","src":"images/npc_npc_11_0_8.png"}],"stats":{"å±žæ€§1":"","å±žæ€§2":""},"customStatus":{"initiative":"","statuses":[{"label":"HP","value":"","max":""},{"label":"MP","value":"","max":""}],"params":[]},"initiative":"","commands":""}];
    const headings = [{"id":"heading-1763876955777-0","text":"â˜ªåäºŒæ˜Ÿåº§é¤¨æ®ºäººäº‹ä»¶","level":1},{"id":"heading-1763881921896-1","text":"ã€Šå…±é€šï½œð•€ã€‹","level":2}];
    const npcGroups = [{"id":"npc-group-mib5q1bh-9yik6","name":"ðŸ”¯é»ƒé“åäºŒæ˜Ÿåº§","collapsed":false,"npcOrder":["npc-1763873435522","npc-1763873407706","npc-1763872771483","npc-1763873444018","npc-1763872819395","npc-1763872794219","npc-1763873428482","npc-1763873461906","npc-1763873452322","npc-1763873342666","npc-1763873369915","npc-1763872097772"]},{"id":"npc-group-mib93ok9-qbncs","name":"ç»„1","collapsed":false,"npcOrder":[]}];
    const settings = {"headingStyles":{"p":{"color":"#1f2937","bg":"#e0e1eb","font":"inherit","size":"16px","lineHeight":"1.4","underlineColor":"transparent","underlineWidth":"0","underlineStyle":"solid"},"h1":{"color":"#f2f2f2","bg":"#1b294b","font":"inherit","size":"32px","underlineColor":"#d1d5db","underlineWidth":"0px","underlineStyle":"solid"},"h2":{"color":"#f2f2f2","bg":"#293e70","font":"inherit","size":"26px","underlineColor":"#e5e7eb","underlineWidth":"0px","underlineStyle":"solid"},"h3":{"color":"#1f2937","bg":"transparent","font":"inherit","size":"21px","underlineColor":"transparent","underlineWidth":"0","underlineStyle":"solid"},"h4":{"color":"#1f2937","bg":"transparent","font":"inherit","size":"18px","underlineColor":"transparent","underlineWidth":"0","underlineStyle":"solid"},"h5":{"color":"#1f2937","bg":"transparent","font":"inherit","size":"16px","underlineColor":"transparent","underlineWidth":"0","underlineStyle":"solid"},"h6":{"color":"#1f2937","bg":"transparent","font":"inherit","size":"15px","underlineColor":"transparent","underlineWidth":"0","underlineStyle":"solid"}},"panelWidths":{"npc":529.166748046875},"tocMaxLevel":6};
    const viewerText = {"lang":"zh","tocToggleTitle":"éšè—ç›®å½•","tocToggleLabel":"ç›®å½•","tocTitle":"ç›®å½•","tocDepthLabel":"ç›®å½•ä¸­åŒ…å«çš„æœ€å¤§æ ‡é¢˜çº§åˆ«","tocDepthAria":"ç›®å½•ä¸­åŒ…å«çš„æœ€å¤§æ ‡é¢˜çº§åˆ«","npcToggleTitle":"è§’è‰²ç®¡ç†","npcToggleLabel":"è§’è‰²","npcPanelHeading":"è§’è‰²ç®¡ç†","resizerAria":"è°ƒæ•´è§’è‰²é¢æ¿å®½åº¦","viewModePaged":"åˆ†é¡µæ˜¾ç¤º","viewModeAll":"æ˜¾ç¤ºå…¨éƒ¨","dialogueStyleBubble":"å¯¹è¯ï¼šæ°”æ³¡","dialogueStyleQuote":"å¯¹è¯ï¼šå¼•å·","rubyVisible":"æ³¨éŸ³ï¼šæ˜¾ç¤º","rubyHidden":"æ³¨éŸ³ï¼šéšè—","expressionTagOn":"è¡¨æƒ…æ ‡ç­¾ï¼šå¼€","expressionTagOff":"è¡¨æƒ…æ ‡ç­¾ï¼šå…³","prevPage":"ä¸Šä¸€é¡µ","nextPage":"ä¸‹ä¸€é¡µ","tocExpand":"å±•å¼€","tocCollapse":"æ”¶èµ·","tocEmpty":"æ²¡æœ‰æ ‡é¢˜","tocLevelOption":"æœ€å¤šåˆ° H{{level}}","languageLabel":"è¯­è¨€","languageAria":"é€‰æ‹©æ˜¾ç¤ºè¯­è¨€","themeToggleTitle":"ä¸»é¢˜","themeToggleDark":"æ·±è‰²","themeToggleLight":"æµ…è‰²","languageOptions":{"ja":"æ—¥è¯­","en":"è‹±è¯­","zh":"ä¸­æ–‡","ko":"éŸ©è¯­"},"copyButtonTitle":"å¤åˆ¶åˆ°å‰ªè´´æ¿","copyButtonSuccess":"å·²å¤åˆ¶!","copyJsonTitle":"å¤åˆ¶ CCFOL JSON","npcEmpty":"æ²¡æœ‰è§’è‰²","npcGroupDefault":"è§’è‰²","npcGroupEmpty":"æ²¡æœ‰è§’è‰²","npcNone":"æ— ","npcNotSet":"æœªè®¾ç½®","npcInitiative":"å…ˆæ”»","npcBriefHeading":"ç®€è¦è¯´æ˜Ž","npcDetailHeading":"è¯¦ç»†è¯´æ˜Ž","npcStatusHeading":"çŠ¶æ€","npcParamsHeading":"å‚æ•°ï¼ˆå…¶ä»–èƒ½åŠ›å€¼ï¼‰","npcCommandsHeading":"èŠå¤©æŒ‡ä»¤","npcCommandsCopy":"å¤åˆ¶","modalClose":"å…³é—­","dialogueBadge":"å¯¹è¯ {{count}} æ¡","paginationInfo":"{{current}} / {{total}}","placeholderButton":"å ä½ç¬¦","placeholderButtonTitle":"å ä½ç¬¦ç®¡ç†","placeholderModalTitle":"å ä½ç¬¦ç®¡ç†","placeholderModalDescription":"è®¾ç½®æ­£æ–‡ä¸­ {HO1} ç­‰å ä½ç¬¦çš„é»˜è®¤æ›¿æ¢æ–‡æœ¬ã€‚","placeholderTokenLabel":"å ä½ç¬¦","placeholderNoteLabel":"å¤‡æ³¨","placeholderValueLabel":"é»˜è®¤å€¼","placeholderEmpty":"å½“å‰æ²¡æœ‰å ä½ç¬¦ã€‚","placeholderSave":"ä¿å­˜","placeholderCancel":"å–æ¶ˆ","placeholderValuePlaceholder":"ä¾‹å¦‚ï¼šç¾½æŸ´èŽ²","placeholderNotePlaceholder":"ä¾‹å¦‚ï¼šPC1 åç§°"};
    const placeholders = [{"id":"placeholder-mib603fs-q1t7","token":"GM å¤‡æ³¨","label":"","value":"ã€KPç´™ç®±ï½œæ˜Ÿåº§é¤¨é¤¨ä¸»(å‰ç…å­)ã€‘"}];
    const PLACEHOLDER_ICON = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA4MCA4MCI+PHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IiNkMWQ1ZGIiLz48dGV4dCB4PSI0MCIgeT0iNTIiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjQyIiBmaWxsPSIjNzM3NDg0Ij4/PC90ZXh0Pjwvc3ZnPg==";
    const viewerLanguageBundles = {"ja":{"lang":"ja","tocToggleTitle":"ç›®æ¬¡ã‚’éš ã™","tocToggleLabel":"ç›®æ¬¡","tocTitle":"ç›®æ¬¡","tocDepthLabel":"ç›®æ¬¡ã«å«ã‚ã‚‹æœ€å¤§è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«","tocDepthAria":"ç›®æ¬¡ã«å«ã‚ã‚‹æœ€å¤§è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«","npcToggleTitle":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç®¡ç†","npcToggleLabel":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼","npcPanelHeading":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç®¡ç†","resizerAria":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‘ãƒãƒ«å¹…ã®èª¿æ•´","viewModePaged":"ãƒšãƒ¼ã‚¸è¡¨ç¤º","viewModeAll":"å…¨ã¦è¡¨ç¤º","dialogueStyleBubble":"ä¼šè©±: å¹ãå‡ºã—","dialogueStyleQuote":"ä¼šè©±: ã‹ãŽã‹ã£ã“","rubyVisible":"ãƒ«ãƒ“: è¡¨ç¤º","rubyHidden":"ãƒ«ãƒ“: éžè¡¨ç¤º","expressionTagOn":"è¡¨æƒ…ã‚¿ã‚°: ã‚ªãƒ³","expressionTagOff":"è¡¨æƒ…ã‚¿ã‚°: ã‚ªãƒ•","prevPage":"å‰ã®ãƒšãƒ¼ã‚¸","nextPage":"æ¬¡ã®ãƒšãƒ¼ã‚¸","tocExpand":"å±•é–‹ã™ã‚‹","tocCollapse":"æŠ˜ã‚Šç•³ã‚€","tocEmpty":"è¦‹å‡ºã—ã¯ã‚ã‚Šã¾ã›ã‚“","tocLevelOption":"H{{level}}ã¾ã§","languageLabel":"è¨€èªž","languageAria":"è¡¨ç¤ºè¨€èªžã‚’é¸æŠž","themeToggleTitle":"ãƒ†ãƒ¼ãƒž","themeToggleDark":"ãƒ€ãƒ¼ã‚¯","themeToggleLight":"ãƒ©ã‚¤ãƒˆ","languageOptions":{"ja":"æ—¥æœ¬èªž","en":"è‹±èªž","zh":"ä¸­å›½èªž","ko":"éŸ“å›½èªž"},"copyButtonTitle":"ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼","copyButtonSuccess":"ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ!","copyJsonTitle":"ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢ç”¨JSONã‚’ã‚³ãƒ”ãƒ¼","npcEmpty":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯ã„ã¾ã›ã‚“","npcGroupDefault":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼","npcGroupEmpty":"ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯ã„ã¾ã›ã‚“","npcNone":"ãªã—","npcNotSet":"æœªè¨­å®š","npcInitiative":"ã‚¤ãƒ‹ã‚·ã‚¢ãƒ†ã‚£ãƒ–","npcBriefHeading":"ç°¡æ˜“èª¬æ˜Ž","npcDetailHeading":"è©³ç´°èª¬æ˜Ž","npcStatusHeading":"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹","npcParamsHeading":"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼ˆãã®ä»–èƒ½åŠ›å€¤ï¼‰","npcCommandsHeading":"ãƒãƒ£ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆ","npcCommandsCopy":"ã‚³ãƒ”ãƒ¼","modalClose":"é–‰ã˜ã‚‹","dialogueBadge":"ä¼šè©± {{count}}ä»¶","paginationInfo":"{{current}} / {{total}}","placeholderButton":"ç½®æ›ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼","placeholderButtonTitle":"ç½®æ›ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼","placeholderModalTitle":"ç½®æ›ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç®¡ç†","placeholderModalDescription":"æœ¬æ–‡ã«æ›¸ã„ãŸ {HO1} ãªã©ã®æ–‡å­—åˆ—ã«ã€ç½®æ›å¾Œã®åå‰ã‚’è¨­å®šã—ã¾ã™ã€‚","placeholderTokenLabel":"ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼","placeholderNoteLabel":"ãƒ¡ãƒ¢","placeholderValueLabel":"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤","placeholderEmpty":"ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚","placeholderSave":"ä¿å­˜","placeholderCancel":"ã‚­ãƒ£ãƒ³ã‚»ãƒ«","placeholderValuePlaceholder":"ä¾‹: ç¾½æŸ´ è“®","placeholderNotePlaceholder":"ãƒãƒ³ãƒ‰ã‚¢ã‚¦ãƒˆ1ã®åå‰"},"en":{"lang":"en","tocToggleTitle":"Hide table of contents","tocToggleLabel":"TOC","tocTitle":"Table of Contents","tocDepthLabel":"Maximum heading level in table of contents","tocDepthAria":"Maximum heading level in table of contents","npcToggleTitle":"Character manager","npcToggleLabel":"Characters","npcPanelHeading":"Character Manager","resizerAria":"Adjust character panel width","viewModePaged":"Page View","viewModeAll":"Show All","dialogueStyleBubble":"Dialogue: Speech Bubble","dialogueStyleQuote":"Dialogue: Quotation","rubyVisible":"Ruby: On","rubyHidden":"Ruby: Off","expressionTagOn":"Expression Tag: On","expressionTagOff":"Expression Tag: Off","prevPage":"Previous Page","nextPage":"Next Page","tocExpand":"Expand","tocCollapse":"Collapse","tocEmpty":"No headings","tocLevelOption":"Up to H{{level}}","languageLabel":"Language","languageAria":"Select display language","themeToggleTitle":"Theme","themeToggleDark":"Dark","themeToggleLight":"Light","languageOptions":{"ja":"Japanese","en":"English","zh":"Chinese","ko":"Korean"},"copyButtonTitle":"Copy to clipboard","copyButtonSuccess":"Copied!","copyJsonTitle":"Copy JSON for CCFOL","npcEmpty":"No characters","npcGroupDefault":"Characters","npcGroupEmpty":"No characters","npcNone":"None","npcNotSet":"Not set","npcInitiative":"Initiative","npcBriefHeading":"Summary","npcDetailHeading":"Detailed Description","npcStatusHeading":"Status","npcParamsHeading":"Parameters","npcCommandsHeading":"Chat Palette","npcCommandsCopy":"Copy","modalClose":"Close","dialogueBadge":"Dialogue {{count}}","paginationInfo":"{{current}} / {{total}}","placeholderButton":"Placeholders","placeholderButtonTitle":"Manage placeholders","placeholderModalTitle":"Manage Placeholders","placeholderModalDescription":"Define tokens such as {HO1} and set the default replacement text.","placeholderTokenLabel":"Token","placeholderNoteLabel":"Note","placeholderValueLabel":"Default value","placeholderEmpty":"No placeholders yet.","placeholderSave":"Save","placeholderCancel":"Cancel","placeholderValuePlaceholder":"e.g. Ren Hashiba","placeholderNotePlaceholder":"PC1 name"},"zh":{"lang":"zh","tocToggleTitle":"éšè—ç›®å½•","tocToggleLabel":"ç›®å½•","tocTitle":"ç›®å½•","tocDepthLabel":"ç›®å½•ä¸­åŒ…å«çš„æœ€å¤§æ ‡é¢˜çº§åˆ«","tocDepthAria":"ç›®å½•ä¸­åŒ…å«çš„æœ€å¤§æ ‡é¢˜çº§åˆ«","npcToggleTitle":"è§’è‰²ç®¡ç†","npcToggleLabel":"è§’è‰²","npcPanelHeading":"è§’è‰²ç®¡ç†","resizerAria":"è°ƒæ•´è§’è‰²é¢æ¿å®½åº¦","viewModePaged":"åˆ†é¡µæ˜¾ç¤º","viewModeAll":"æ˜¾ç¤ºå…¨éƒ¨","dialogueStyleBubble":"å¯¹è¯ï¼šæ°”æ³¡","dialogueStyleQuote":"å¯¹è¯ï¼šå¼•å·","rubyVisible":"æ³¨éŸ³ï¼šæ˜¾ç¤º","rubyHidden":"æ³¨éŸ³ï¼šéšè—","expressionTagOn":"è¡¨æƒ…æ ‡ç­¾ï¼šå¼€","expressionTagOff":"è¡¨æƒ…æ ‡ç­¾ï¼šå…³","prevPage":"ä¸Šä¸€é¡µ","nextPage":"ä¸‹ä¸€é¡µ","tocExpand":"å±•å¼€","tocCollapse":"æ”¶èµ·","tocEmpty":"æ²¡æœ‰æ ‡é¢˜","tocLevelOption":"æœ€å¤šåˆ° H{{level}}","languageLabel":"è¯­è¨€","languageAria":"é€‰æ‹©æ˜¾ç¤ºè¯­è¨€","themeToggleTitle":"ä¸»é¢˜","themeToggleDark":"æ·±è‰²","themeToggleLight":"æµ…è‰²","languageOptions":{"ja":"æ—¥è¯­","en":"è‹±è¯­","zh":"ä¸­æ–‡","ko":"éŸ©è¯­"},"copyButtonTitle":"å¤åˆ¶åˆ°å‰ªè´´æ¿","copyButtonSuccess":"å·²å¤åˆ¶!","copyJsonTitle":"å¤åˆ¶ CCFOL JSON","npcEmpty":"æ²¡æœ‰è§’è‰²","npcGroupDefault":"è§’è‰²","npcGroupEmpty":"æ²¡æœ‰è§’è‰²","npcNone":"æ— ","npcNotSet":"æœªè®¾ç½®","npcInitiative":"å…ˆæ”»","npcBriefHeading":"ç®€è¦è¯´æ˜Ž","npcDetailHeading":"è¯¦ç»†è¯´æ˜Ž","npcStatusHeading":"çŠ¶æ€","npcParamsHeading":"å‚æ•°ï¼ˆå…¶ä»–èƒ½åŠ›å€¼ï¼‰","npcCommandsHeading":"èŠå¤©æŒ‡ä»¤","npcCommandsCopy":"å¤åˆ¶","modalClose":"å…³é—­","dialogueBadge":"å¯¹è¯ {{count}} æ¡","paginationInfo":"{{current}} / {{total}}","placeholderButton":"å ä½ç¬¦","placeholderButtonTitle":"å ä½ç¬¦ç®¡ç†","placeholderModalTitle":"å ä½ç¬¦ç®¡ç†","placeholderModalDescription":"è®¾ç½®æ­£æ–‡ä¸­ {HO1} ç­‰å ä½ç¬¦çš„é»˜è®¤æ›¿æ¢æ–‡æœ¬ã€‚","placeholderTokenLabel":"å ä½ç¬¦","placeholderNoteLabel":"å¤‡æ³¨","placeholderValueLabel":"é»˜è®¤å€¼","placeholderEmpty":"å½“å‰æ²¡æœ‰å ä½ç¬¦ã€‚","placeholderSave":"ä¿å­˜","placeholderCancel":"å–æ¶ˆ","placeholderValuePlaceholder":"ä¾‹å¦‚ï¼šç¾½æŸ´èŽ²","placeholderNotePlaceholder":"ä¾‹å¦‚ï¼šPC1 åç§°"},"ko":{"lang":"ko","tocToggleTitle":"ëª©ì°¨ ìˆ¨ê¸°ê¸°","tocToggleLabel":"ëª©ì°¨","tocTitle":"ëª©ì°¨","tocDepthLabel":"ëª©ì°¨ì— í¬í•¨í•  ìµœëŒ€ ì œëª© ìˆ˜ì¤€","tocDepthAria":"ëª©ì°¨ì— í¬í•¨í•  ìµœëŒ€ ì œëª© ìˆ˜ì¤€","npcToggleTitle":"ìºë¦­í„° ê´€ë¦¬","npcToggleLabel":"ìºë¦­í„°","npcPanelHeading":"ìºë¦­í„° ê´€ë¦¬","resizerAria":"ìºë¦­í„° íŒ¨ë„ ë„ˆë¹„ ì¡°ì ˆ","viewModePaged":"íŽ˜ì´ì§€ ë³´ê¸°","viewModeAll":"ì „ì²´ ë³´ê¸°","dialogueStyleBubble":"ëŒ€ì‚¬: ë§í’ì„ ","dialogueStyleQuote":"ëŒ€ì‚¬: ë”°ì˜´í‘œ","rubyVisible":"ë£¨ë¹„: í‘œì‹œ","rubyHidden":"ë£¨ë¹„: ìˆ¨ê¹€","expressionTagOn":"í‘œì • íƒœê·¸: ì¼œì§","expressionTagOff":"í‘œì • íƒœê·¸: êº¼ì§","prevPage":"ì´ì „ íŽ˜ì´ì§€","nextPage":"ë‹¤ìŒ íŽ˜ì´ì§€","tocExpand":"íŽ¼ì¹˜ê¸°","tocCollapse":"ì ‘ê¸°","tocEmpty":"ëª©ì°¨ê°€ ì—†ìŠµë‹ˆë‹¤","tocLevelOption":"H{{level}}ê¹Œì§€","languageLabel":"ì–¸ì–´","languageAria":"í‘œì‹œ ì–¸ì–´ ì„ íƒ","themeToggleTitle":"í…Œë§ˆ","themeToggleDark":"ë‹¤í¬","themeToggleLight":"ë¼ì´íŠ¸","languageOptions":{"ja":"ì¼ë³¸ì–´","en":"ì˜ì–´","zh":"ì¤‘êµ­ì–´","ko":"í•œêµ­ì–´"},"copyButtonTitle":"í´ë¦½ë³´ë“œì— ë³µì‚¬","copyButtonSuccess":"ë³µì‚¬ ì™„ë£Œ!","copyJsonTitle":"CCFOL JSON ë³µì‚¬","npcEmpty":"ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤","npcGroupDefault":"ìºë¦­í„°","npcGroupEmpty":"ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤","npcNone":"ì—†ìŒ","npcNotSet":"ë¯¸ì„¤ì •","npcInitiative":"ì´ë‹ˆì…”í‹°ë¸Œ","npcBriefHeading":"ê°„ë‹¨ ì„¤ëª…","npcDetailHeading":"ìƒì„¸ ì„¤ëª…","npcStatusHeading":"ìŠ¤í…Œì´í„°ìŠ¤","npcParamsHeading":"íŒŒë¼ë¯¸í„°(ì¶”ê°€ ëŠ¥ë ¥ì¹˜)","npcCommandsHeading":"ì±„íŒ… íŒ”ë ˆíŠ¸","npcCommandsCopy":"ë³µì‚¬","modalClose":"ë‹«ê¸°","dialogueBadge":"ëŒ€ì‚¬ {{count}}ê°œ","paginationInfo":"{{current}} / {{total}}","placeholderButton":"í”Œë ˆì´ìŠ¤í™€ë”","placeholderButtonTitle":"í”Œë ˆì´ìŠ¤í™€ë” ê´€ë¦¬","placeholderModalTitle":"í”Œë ˆì´ìŠ¤í™€ë” ê´€ë¦¬","placeholderModalDescription":"{HO1}ì™€ ê°™ì€ í† í°ì„ ì •ì˜í•˜ê³  ê¸°ë³¸ ëŒ€ì²´ í…ìŠ¤íŠ¸ë¥¼ ì„¤ì •í•˜ì„¸ìš”.","placeholderTokenLabel":"í† í°","placeholderNoteLabel":"ë©”ëª¨","placeholderValueLabel":"ê¸°ë³¸ ê°’","placeholderEmpty":"ë“±ë¡ëœ í”Œë ˆì´ìŠ¤í™€ë”ê°€ ì—†ìŠµë‹ˆë‹¤.","placeholderSave":"ì €ìž¥","placeholderCancel":"ì·¨ì†Œ","placeholderValuePlaceholder":"ì˜ˆ: í•˜ì‹œë°” ë Œ","placeholderNotePlaceholder":"ì˜ˆ: PC1 ì´ë¦„"}};
    const viewerDefaultLanguage = (viewerText && viewerText.lang) ? viewerText.lang : 'ja';

    function formatTemplate(template, params) {
        if (typeof template !== 'string') return template == null ? '' : String(template);
        if (!params) return template;
        return template.replace(/\{\{\s*(\w+)\s*\}\}/g, function (_, key) {
            return Object.prototype.hasOwnProperty.call(params, key)
                ? String(params[key])
                : '';
        });
    }

    function getViewerBundle(lang) {
        if (viewerLanguageBundles && Object.prototype.hasOwnProperty.call(viewerLanguageBundles, lang)) {
            return viewerLanguageBundles[lang] || {};
        }
        if (viewerLanguageBundles && Object.prototype.hasOwnProperty.call(viewerLanguageBundles, viewerDefaultLanguage)) {
            return viewerLanguageBundles[viewerDefaultLanguage] || {};
        }
        const bundleKeys = viewerLanguageBundles ? Object.keys(viewerLanguageBundles) : [];
        if (bundleKeys.length) {
            const first = bundleKeys[0];
            return viewerLanguageBundles[first] || {};
        }
        return viewerText || {};
    }

    function normalizeViewerLanguage(lang) {
        if (viewerLanguageBundles && Object.prototype.hasOwnProperty.call(viewerLanguageBundles, lang)) {
            return lang;
        }
        if (viewerLanguageBundles && Object.prototype.hasOwnProperty.call(viewerLanguageBundles, viewerDefaultLanguage)) {
            return viewerDefaultLanguage;
        }
        if (viewerText && viewerText.lang) return viewerText.lang;
        const bundleKeys = viewerLanguageBundles ? Object.keys(viewerLanguageBundles) : [];
        return bundleKeys.length ? bundleKeys[0] : 'ja';
    }

let currentViewerLanguage = normalizeViewerLanguage(viewerDefaultLanguage);
let activeViewerText = getViewerBundle(currentViewerLanguage);
    const VIEWER_LANGUAGE_STORAGE_KEY = 'trpg-viewer-language';

    try {
        if (typeof localStorage !== 'undefined') {
            const storedLanguage = localStorage.getItem(VIEWER_LANGUAGE_STORAGE_KEY);
            if (storedLanguage) {
                const normalized = normalizeViewerLanguage(storedLanguage);
                currentViewerLanguage = normalized;
                activeViewerText = getViewerBundle(normalized);
            }
        }
    } catch (_) {}

    function vt(key, fallback, params) {
        if (activeViewerText && Object.prototype.hasOwnProperty.call(activeViewerText, key)) {
            const template = activeViewerText[key];
            if (typeof template === 'string') {
                return params ? formatTemplate(template, params) : template;
            }
        }
        const defaultBundle = getViewerBundle(viewerDefaultLanguage);
        if (defaultBundle && Object.prototype.hasOwnProperty.call(defaultBundle, key)) {
            const template = defaultBundle[key];
            if (typeof template === 'string') {
                return params ? formatTemplate(template, params) : template;
            }
        }
        if (viewerText && Object.prototype.hasOwnProperty.call(viewerText, key)) {
            const template = viewerText[key];
            if (typeof template === 'string') {
                return params ? formatTemplate(template, params) : template;
            }
        }
        return fallback !== undefined ? fallback : '';
    }
    function loadStoredThemePreference() {
        if (typeof localStorage === 'undefined') return null;
        try {
            const stored = localStorage.getItem(THEME_STORAGE_KEY);
            if (stored === 'dark' || stored === 'light' || stored === 'system') {
                return stored;
            }
            return null;
        } catch (_) {
            return null;
        }
    }

    function saveThemePreference(pref) {
        if (typeof localStorage === 'undefined') return;
        try {
            if (pref === 'system') {
                localStorage.removeItem(THEME_STORAGE_KEY);
            } else {
                localStorage.setItem(THEME_STORAGE_KEY, pref);
            }
        } catch (_) {}
    }

    function resolveEffectiveTheme(pref) {
        if (pref === 'dark' || pref === 'light') return pref;
        if (prefersDarkScheme && prefersDarkScheme.matches) {
            return 'dark';
        }
        return 'light';
    }

    function subscribeToSystemTheme(listener) {
        if (!prefersDarkScheme || typeof listener !== 'function') return;
        if (typeof prefersDarkScheme.addEventListener === 'function') {
            prefersDarkScheme.addEventListener('change', listener);
        } else if (typeof prefersDarkScheme.addListener === 'function') {
            prefersDarkScheme.addListener(listener);
        }
    }

    function refreshThemeToggleLabel(pref, effective) {
        if (!themeToggleBtn) return;
        const nextEffective = effective !== undefined ? effective : resolveEffectiveTheme(pref === undefined ? themePreference : pref);
        const label = nextEffective === 'dark'
            ? vt('themeToggleDark', themeToggleBtn.textContent || 'Dark')
            : vt('themeToggleLight', themeToggleBtn.textContent || 'Light');
        themeToggleBtn.textContent = label;
        themeToggleBtn.setAttribute('aria-pressed', nextEffective === 'dark' ? 'true' : 'false');
    }

    const COLOR_RESOLVER = document.createElement('span');
    COLOR_RESOLVER.style.position = 'absolute';
    COLOR_RESOLVER.style.opacity = '0';
    COLOR_RESOLVER.style.pointerEvents = 'none';
    COLOR_RESOLVER.style.height = '0';
    if (document.body && !COLOR_RESOLVER.parentNode) {
        document.body.appendChild(COLOR_RESOLVER);
    }

    function normalizeHex(hex) {
        if (!hex) return null;
        let value = String(hex).trim();
        if (!value) return null;
        if (!value.startsWith('#')) return null;
        if (value.length === 4) {
            value = '#' + value.slice(1).split('').map((c) => c + c).join('');
        }
        if (value.length !== 7) return null;
        return value.toLowerCase();
    }

    function resolveColorToHex(value) {
        if (!value) return null;
        const input = String(value).trim();
        if (
            !input ||
            input === 'transparent' ||
            input === 'initial' ||
            input === 'inherit' ||
            input === 'rgba(0, 0, 0, 0)'
        ) {
            return null;
        }
        if (input.startsWith('#')) {
            return normalizeHex(input);
        }
        const rgbMatch = input.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d+))?\)$/i);
        if (rgbMatch) {
            const r = parseInt(rgbMatch[1], 10);
            const g = parseInt(rgbMatch[2], 10);
            const b = parseInt(rgbMatch[3], 10);
            const a = rgbMatch[4] !== undefined ? parseFloat(rgbMatch[4]) : 1;
            if (
                Number.isNaN(r) ||
                Number.isNaN(g) ||
                Number.isNaN(b) ||
                Number.isNaN(a) ||
                a === 0
            ) {
                return null;
            }
            const hex = '#' + [r, g, b].map((n) => Math.max(0, Math.min(255, n)).toString(16).padStart(2, '0')).join('');
            return normalizeHex(hex);
        }
        if (document.body && !COLOR_RESOLVER.parentNode) {
            document.body.appendChild(COLOR_RESOLVER);
        }
        COLOR_RESOLVER.style.color = input;
        const computed = window.getComputedStyle(COLOR_RESOLVER).color;
        if (computed && computed !== input) {
            return resolveColorToHex(computed);
        }
        return null;
    }

    const VIEWER_DEFAULT_TEXT_COLORS = new Set(
        [
            '#000000',
            '#0f172a',
            '#111827',
            '#1f2937',
            '#334155',
            '#374151',
            '#4b5563',
            '#475569',
            '#5b5b5b',
            '#64748b',
            '#6b7280',
            '#71717a',
            '#818181',
            '#838383',
            '#8f8f8f',
            '#94a3b8',
            '#9ca3af',
            '#a1a1aa',
            '#b3b3b3',
            '#cbd5f5',
            '#d1d5db',
            '#d4d4d8',
            '#e2e8f0',
            '#e5e7eb',
            '#f1f5f9',
            '#f8fafc'
        ].map((hex) => {
            const normalized = normalizeHex(hex);
            return normalized ? normalized.toLowerCase() : hex.toLowerCase();
        })
    );
    const VIEWER_DEFAULT_CUSTOM_COLOR_PROPS = ['--box-text', '--speaker-color'];

    function unwrapElementPreserveChildren(node) {
        if (!node || !node.parentNode) return;
        const parent = node.parentNode;
        while (node.firstChild) {
            parent.insertBefore(node.firstChild, node);
        }
        parent.removeChild(node);
    }

    function stripDefaultViewerCustomColor(node, property) {
        if (
            !node ||
            !node.style ||
            typeof node.style.getPropertyValue !== 'function'
        )
            return;
        const raw = node.style.getPropertyValue(property);
        if (!raw) return;
        const normalized = resolveColorToHex(raw);
        if (!normalized) return;
        const normalizedLower = normalized.toLowerCase();
        if (!VIEWER_DEFAULT_TEXT_COLORS.has(normalizedLower)) return;
        node.style.removeProperty(property);
        const remainingStyle = node.getAttribute('style');
        if (!remainingStyle || !remainingStyle.trim()) {
            node.removeAttribute('style');
        }
    }

    function normalizeViewerInlineTextColors(scope) {
        if (!scope || !scope.querySelectorAll) return;
        const candidates = scope.querySelectorAll('[style], font[color]');
        const customColorNodes = new Set();
        if (
            scope instanceof Element &&
            scope.style &&
            typeof scope.style.getPropertyValue === 'function'
        ) {
            VIEWER_DEFAULT_CUSTOM_COLOR_PROPS.forEach((prop) => {
                if (scope.style.getPropertyValue(prop)) {
                    customColorNodes.add(scope);
                }
            });
        }
        candidates.forEach((node) => {
            const hasInlineColor =
                node.style &&
                typeof node.style.color === 'string' &&
                node.style.color.trim().length > 0;
            if (
                node.style &&
                typeof node.style.getPropertyValue === 'function'
            ) {
                VIEWER_DEFAULT_CUSTOM_COLOR_PROPS.forEach((prop) => {
                    if (node.style.getPropertyValue(prop)) {
                        customColorNodes.add(node);
                    }
                });
            }
            const hasFontColor =
                node.tagName === 'FONT' &&
                node.hasAttribute('color');
            if (!hasInlineColor && !hasFontColor) return;
            let normalized = null;
            if (hasInlineColor) {
                normalized = resolveColorToHex(node.style.color);
            }
            if (!normalized && hasFontColor) {
                normalized = resolveColorToHex(node.getAttribute('color'));
            }
            if (!normalized) {
                try {
                    normalized = resolveColorToHex(window.getComputedStyle(node).color);
                } catch (_) {
                    normalized = null;
                }
            }
            if (!normalized) return;
            const normalizedLower = normalized.toLowerCase();
            if (!VIEWER_DEFAULT_TEXT_COLORS.has(normalizedLower)) return;
            if (hasInlineColor) {
                node.style.removeProperty('color');
                if (!node.getAttribute('style')) {
                    node.removeAttribute('style');
                }
            }
            if (hasFontColor) {
                node.removeAttribute('color');
            }
            if (
                (node.tagName === 'SPAN' || node.tagName === 'FONT') &&
                node.attributes.length === 0
            ) {
                unwrapElementPreserveChildren(node);
            }
        });
        customColorNodes.forEach((node) => {
            VIEWER_DEFAULT_CUSTOM_COLOR_PROPS.forEach((prop) => {
                stripDefaultViewerCustomColor(node, prop);
            });
        });
    }

    function applyThemePreference(pref, options) {
        themePreference = pref;
        const effective = resolveEffectiveTheme(pref);
        if (body) {
            body.classList.toggle('dark-mode', effective === 'dark');
            body.setAttribute('data-theme-pref', pref);
        }
        if (root) {
            root.setAttribute('data-theme', effective);
        }
        refreshThemeToggleLabel(pref, effective);
        if (main) {
            normalizeViewerInlineTextColors(main);
        }
        const shouldPersist = !options || options.persist !== false;
        if (shouldPersist) {
            saveThemePreference(pref);
        }
    }
    const main = document.getElementById('viewer-main');
    const body = document.body;
    const root = document.documentElement;
    if (root) {
        root.setAttribute('lang', activeViewerText.lang || currentViewerLanguage);
    }
    const headingsPanel = document.getElementById('headings-panel-export');
    const npcPanel = document.getElementById('npc-panel-export');
    const npcPanelResizer = document.getElementById('npc-panel-resizer-export');
    const toggleHeadingsBtn = document.getElementById('toggle-headings-btn-export');
    const toggleNpcsBtn = document.getElementById('toggle-npcs-btn-export');
    const npcPanelHeadingEl = document.getElementById('npc-panel-heading');
    const viewerLanguageSelect = document.getElementById('viewer-language-select');
    const viewerLanguageLabelEl = document.getElementById('viewer-language-label');
    const placeholderToggleBtn = document.getElementById('placeholder-toggle');
    const placeholderModalEl = document.getElementById('placeholder-modal-export');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const THEME_STORAGE_KEY = 'trpg-editor-theme';
    const prefersDarkScheme = typeof window.matchMedia === 'function'
        ? window.matchMedia('(prefers-color-scheme: dark)')
        : null;
    let themePreference = loadStoredThemePreference();
    if (!themePreference) {
        const bodyPref = body && body.getAttribute('data-theme-pref');
        if (bodyPref === 'dark' || bodyPref === 'light') {
            themePreference = bodyPref;
        } else {
            themePreference = 'system';
        }
    }
    applyThemePreference(themePreference, { persist: false });
    if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', function () {
            const next =
                resolveEffectiveTheme(themePreference) === 'dark'
                    ? 'light'
                    : 'dark';
            applyThemePreference(next);
        });
    }
    subscribeToSystemTheme(function () {
        if (themePreference === 'system') {
            applyThemePreference('system', { persist: false });
        }
    });
    // View Mode Logic
    const viewModeToggle = document.getElementById('view-mode-toggle');
    const dialogueStyleToggle = document.getElementById('dialogue-style-toggle');
    const rubyToggle = document.getElementById('ruby-toggle');
    const expressionTagToggle = document.getElementById('expression-tag-toggle');
    const paginationAreas = [
        {
            container: document.getElementById('pagination-controls-export'),
            pageInfo: document.getElementById('page-info-export'),
            prev: document.getElementById('prev-page-btn-export'),
            next: document.getElementById('next-page-btn-export')
        },
        {
            container: document.getElementById('pagination-controls-export-top'),
            pageInfo: document.getElementById('page-info-export-top'),
            prev: document.getElementById('prev-page-btn-export-top'),
            next: document.getElementById('next-page-btn-export-top')
        }
    ].filter(area => area.container && area.pageInfo && area.prev && area.next);
if (main) {
    normalizeViewerInlineTextColors(main);
}
const originalMainHtml = main ? main.innerHTML : '';
    const originalHeadings = Array.isArray(headings)
        ? headings.map((entry) => ({
              id: entry && entry.id ? String(entry.id) : '',
              level:
                  entry && typeof entry.level !== 'undefined'
                      ? Number(entry.level)
                      : 1,
              text:
                  entry && typeof entry.text === 'string'
                      ? entry.text
                      : '',
          }))
        : [];
    const originalNpcs = Array.isArray(npcs)
        ? JSON.parse(JSON.stringify(npcs))
        : [];
    const originalNpcGroups = Array.isArray(npcGroups)
        ? JSON.parse(JSON.stringify(npcGroups))
        : [];
    const placeholderEntries = Array.isArray(placeholders)
        ? placeholders.filter(
              (item) =>
                  item &&
                  typeof item.token === 'string' &&
                  item.token.trim().length,
          )
        : [];
    let placeholderValues = placeholderEntries.map((item) => ({
        id: item && item.id ? String(item.id) : String(item.token || ''),
        token: String(item.token || ''),
        label:
            item && typeof item.label === 'string' ? item.label : '',
        value:
            item && typeof item.value === 'string' ? item.value : '',
    }));

    function isFreeNameNpc(npc){
        if (!npc) return false;
        if (!placeholderEntries.length) return false;
        const base = originalNpcs.find((candidate) => {
            if (!candidate) return false;
            if (candidate.id != null && npc.id != null) {
                return String(candidate.id) === String(npc.id);
            }
            return candidate === npc;
        }) || npc;
        const nameSource = base && typeof base.name === 'string' ? base.name : '';
        if (!nameSource) return false;
        return placeholderEntries.some((entry) => {
            if (!entry || !entry.token) return false;
            const token = String(entry.token);
            if (!token) return false;
            return nameSource.indexOf(token) !== -1;
        });
    }
    const shouldAutoApplyPlaceholders = placeholderValues.some(
        (entry) => entry && typeof entry.value === 'string' && entry.value.length > 0,
    );
    let isBubbleStyle = true;
    const tocTitleEl = document.getElementById('toc-title-export');
    const tocDepthLabelEl = document.getElementById('toc-depth-label');
    const NPC_PANEL_DEFAULT_WIDTH = 260;
    const NPC_PANEL_MIN_WIDTH = 220;
    const NPC_PANEL_MAX_WIDTH = 640;
    let npcPanelWidth = clampNpcPanelWidth(
        settings && settings.panelWidths ? settings.panelWidths.npc : undefined,
        NPC_PANEL_DEFAULT_WIDTH
    );
    let isNpcPanelResizing = false;
    let npcPanelResizeStartX = 0;
    let npcPanelResizeStartWidth = npcPanelWidth;
    setNpcPanelWidth(npcPanelWidth, true);
    const COPY_BTN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zM-1 1.5A1.5 1.5 0 0 1 .5 0h3A1.5 1.5 0 0 1 5 1.5v1A1.5 1.5 0 0 1 3.5 4h-3A1.5 1.5 0 0 1-1 2.5v-1z"/></svg>';
    const copyBaseSelector = 'p, h1, h2, h3, h4, h5, h6, .npc-dialogue, .info-box, .gm-memo, .secret-box, .handout-box, .skill-box, blockquote';
    const copyWrapperSelector = 'div[data-page-index]';
    function addCopyButton(el){
        if (!el || el.querySelector('.copy-btn-export')) return;
        var text = (el.innerText || '').trim();
        if (!text) return;
        var btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'copy-btn-export';
        var copyTitle = vt('copyButtonTitle', 'Copy to clipboard');
        btn.title = copyTitle;
        btn.setAttribute('aria-label', copyTitle);
        btn.innerHTML = COPY_BTN_SVG;
        el.classList.add('copy-target-export');
        el.appendChild(btn);
    }
    function ensureCopyButtons(container) {
        var root = container || main;
        root.querySelectorAll(copyBaseSelector).forEach(addCopyButton);
        root.querySelectorAll(copyWrapperSelector).forEach(function(el){
            if (el.matches(copyBaseSelector)) return;
            if (el.querySelector(copyBaseSelector)) return;
            addCopyButton(el);
        });
    }
    function esc(s){
        var str = (s==null ? '' : String(s));
        return str
            .replace(/&/g,'&amp;')
            .replace(/</g,'&lt;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/'/g,'&#39;');
    }

    function normalizePathname(pathname){
        if (typeof pathname !== 'string') return '';
        var trimmed = pathname.trim();
        if (!trimmed) return '';
        return trimmed.replace(/\/+$/, '') || '/';
    }

    function decodeHashFragment(fragment){
        if (!fragment) return '';
        var value = fragment.charAt(0) === '#' ? fragment.slice(1) : fragment;
        if (!value) return '';
        try {
            return decodeURIComponent(value);
        } catch (err) {
            return value;
        }
    }

    function getLocalAnchorId(href){
        if (!href) return '';
        var trimmed = String(href).trim();
        if (!trimmed) return '';
        if (trimmed === '#') return '';
        if (trimmed.charAt(0) === '#') {
            return decodeHashFragment(trimmed);
        }
        try {
            var resolved = new URL(trimmed, window.location.href);
            if (!resolved.hash || resolved.hash === '#') return '';
            if (resolved.protocol !== window.location.protocol) return '';
            if (resolved.host !== window.location.host) return '';
            if (normalizePathname(resolved.pathname) !== normalizePathname(window.location.pathname)) return '';
            if (resolved.search !== window.location.search) return '';
            return decodeHashFragment(resolved.hash);
        } catch (err) {
            return '';
        }
    }

    function findPageIndexForElement(element){
        if (!element) return -1;
        var node = element;
        while (node && node !== main && node.parentElement !== main) {
            node = node.parentElement;
        }
        if (!node || node === main) return -1;
        var pageIndex = elementPageIndex.get(node);
        return typeof pageIndex === 'number' ? pageIndex : -1;
    }

    function scrollToAnchorTarget(targetElement){
        if (!targetElement) return;
        requestAnimationFrame(function(){
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
    }

    function syncPageWithHash(){
        if (!window.location || !window.location.hash) return;
        var targetId = getLocalAnchorId(window.location.hash);
        if (!targetId) return;
        var targetElement = document.getElementById(targetId);
        if (!targetElement) return;
        if (isPaged) {
            var targetPage = findPageIndexForElement(targetElement);
            if (targetPage >= 0 && targetPage !== currentPage) {
                renderPage(targetPage);
            }
        }
        scrollToAnchorTarget(targetElement);
    }

    function handleInternalNavigation(event){
        if (event.defaultPrevented) return;
        if (typeof event.button === 'number' && event.button !== 0) return;
        if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
        var anchor = event.target && event.target.closest ? event.target.closest('a[href]') : null;
        if (!anchor) return;
        var href = anchor.getAttribute('href');
        var targetId = getLocalAnchorId(href);
        if (!targetId) return;
        var targetAttr = anchor.getAttribute('target');
        if (targetAttr) {
            var targetLower = targetAttr.toLowerCase();
            if (targetLower && targetLower !== '_self' && targetLower !== 'self') return;
        }
        if (anchor.hasAttribute('download')) return;
        var targetElement = document.getElementById(targetId);
        if (!targetElement) return;

        event.preventDefault();

        if (isPaged) {
            var targetPage = findPageIndexForElement(targetElement);
            if (targetPage >= 0 && targetPage !== currentPage) {
                renderPage(targetPage);
            }
        }

        scrollToAnchorTarget(targetElement);

        var hashId = targetElement.id || targetId;
        if (hashId) {
            try {
                var urlForHash = new URL(window.location.href);
                var previousHash = urlForHash.hash;
                urlForHash.hash = hashId;
                if (urlForHash.hash !== window.location.hash) {
                    if (typeof history !== 'undefined' && typeof history.pushState === 'function') {
                        history.pushState(null, '', urlForHash.toString());
                    } else {
                        window.location.hash = hashId;
                    }
                } else if (!previousHash) {
                    // Ensure hash is set when previously empty
                    window.location.hash = hashId;
                }
            } catch (err) {
                window.location.hash = hashId;
            }
        }
    }

    function classifyLinkType(href){
        if (!href) return '';
        var trimmed = String(href).trim();
        if (!trimmed) return '';
        if (getLocalAnchorId(trimmed)) return 'internal';
        if (/^(mailto:|tel:)/i.test(trimmed)) return 'external';
        if (/^[a-z][a-z0-9+.-]*:/i.test(trimmed)) return 'external';
        return 'external';
    }

    function annotateLinks(container){
        var scope = container || main;
        if (!scope) return;
        scope.querySelectorAll('a[href]').forEach(function(anchor){
            var href = anchor.getAttribute('href');
            var type = classifyLinkType(href);
            if (!type) {
                anchor.removeAttribute('data-link-type');
                return;
            }
            anchor.setAttribute('data-link-type', type);
            if (!anchor.getAttribute('title')) anchor.setAttribute('title', href);
            if (type === 'external') {
                if (!anchor.target) anchor.target = '_blank';
                var rel = anchor.getAttribute('rel') || '';
                if (!/noopener/i.test(rel)) {
                    anchor.setAttribute('rel', (rel + ' noopener noreferrer').trim());
                }
            }
        });
    }

    function cssEscape(str){
        if (typeof str !== 'string') return '';
        if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
            return CSS.escape(str);
        }
        return str.replace(/["\\]/g, '\\$&');
    }

    function replaceTokensInString(str, replacements){
        if (typeof str !== 'string' || !replacements || !replacements.length) return str;
        var result = str;
        replacements.forEach(function(rep){
            if (!rep || !rep.token) return;
            var token = String(rep.token);
            if (!token.length) return;
            var value = rep.value == null ? '' : String(rep.value);
            if (!value.length) return;
            if (result.indexOf(token) === -1) return;
            result = result.split(token).join(value);
        });
        return result;
    }

    function buildContentWithPlaceholders(html, replacements){
        if (typeof html !== 'string') return '';
        if (!replacements || !replacements.length) return html;
        var container = document.createElement('div');
        container.innerHTML = html;
        var textWalker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
        var node;
        while ((node = textWalker.nextNode())) {
            var nextValue = replaceTokensInString(node.nodeValue, replacements);
            if (nextValue !== node.nodeValue) {
                node.nodeValue = nextValue;
            }
        }
        var elementWalker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, null);
        var el;
        while ((el = elementWalker.nextNode())) {
            if (!el.attributes) continue;
            Array.from(el.attributes).forEach(function(attr){
                var nextAttr = replaceTokensInString(attr.value, replacements);
                if (nextAttr !== attr.value) {
                    el.setAttribute(attr.name, nextAttr);
                }
            });
        }
        return container.innerHTML;
    }

    let placeholderModalBackdropHandler = null;

    function handlePlaceholderEsc(event){
        if (event.key === 'Escape') {
            event.preventDefault();
            closePlaceholderModal();
        }
    }

    function closePlaceholderModal(){
        if (!placeholderModalEl) return;
        placeholderModalEl.classList.remove('show');
        placeholderModalEl.innerHTML = '';
        if (placeholderModalBackdropHandler) {
            placeholderModalEl.removeEventListener('click', placeholderModalBackdropHandler);
            placeholderModalBackdropHandler = null;
        }
        document.removeEventListener('keydown', handlePlaceholderEsc);
    }

    function openPlaceholderModal(){
        if (!placeholderModalEl || !placeholderEntries.length) return;
        var title = vt('placeholderModalTitle', 'Placeholders');
        var description = vt('placeholderModalDescription', '');
        var tokenHeading = vt('placeholderTokenLabel', 'Placeholder');
        var noteHeading = vt('placeholderNoteLabel', 'Note');
        var valueHeading = vt('placeholderValueLabel', 'Value');
        var emptyLabel = vt('placeholderEmpty', 'No placeholders defined.');
        var cancelLabel = vt('placeholderCancel', vt('modalClose', 'Close'));
        var applyLabel = vt('placeholderSave', 'Apply');
        var valuePlaceholder = vt('placeholderValuePlaceholder', '');
        placeholderModalEl.innerHTML = [
            '<div class="modal-content">',
                '<div class="modal-header">',
                    '<h2>' + esc(title) + '</h2>',
                    '<button type="button" class="modal-close" id="placeholder-modal-close">' + esc(cancelLabel) + '</button>',
                '</div>',
                description ? '<p style="color:#4b5563;font-size:0.9rem;">' + esc(description) + '</p>' : '',
                placeholderValues.length
                    ? '<div class="placeholder-modal-body">' + placeholderValues.map(function(entry){
                          var note = entry.label && entry.label.trim() ? entry.label : '';
                          var valueAttr = esc(entry.value || '');
                          var placeholderAttr = esc(valuePlaceholder || '');
                          var displayNote = note ? esc(note) : esc(noteHeading);
                          return '<div class="placeholder-row" data-placeholder-id="' + esc(entry.id) + '">'
                              + '<div><strong>' + esc(entry.token) + '</strong>'
                              + (displayNote ? '<small>' + displayNote + '</small>' : '')
                              + '</div>'
                              + '<label style="display:block;margin-top:0.25rem;font-size:0.85rem;font-weight:600;color:#374151;">' + esc(valueHeading) + '</label>'
                              + '<input type="text" data-placeholder-field="value" value="' + valueAttr + '" placeholder="' + placeholderAttr + '">'
                              + '</div>';
                      }).join('') + '</div>'
                    : '<p class="placeholder-empty">' + esc(emptyLabel) + '</p>',
                '<div class="placeholder-modal-actions">',
                    '<button type="button" class="button-pill button-pill-secondary" id="placeholder-modal-cancel">' + esc(cancelLabel) + '</button>',
                    '<button type="button" class="button-pill button-pill-secondary" id="placeholder-modal-apply">' + esc(applyLabel) + '</button>',
                '</div>',
            '</div>'
        ].join('');
        placeholderModalEl.classList.add('show');
        var closeBtn = placeholderModalEl.querySelector('#placeholder-modal-close');
        var cancelBtn = placeholderModalEl.querySelector('#placeholder-modal-cancel');
        var applyBtn = placeholderModalEl.querySelector('#placeholder-modal-apply');
        var focusTarget = placeholderModalEl.querySelector('input[data-placeholder-field="value"]');
        if (closeBtn) closeBtn.addEventListener('click', closePlaceholderModal);
        if (cancelBtn) cancelBtn.addEventListener('click', closePlaceholderModal);
        if (applyBtn) {
            applyBtn.addEventListener('click', function(){
                var updated = placeholderValues.map(function(entry){
                    var selector = '[data-placeholder-id="' + cssEscape(entry.id) + '"] input[data-placeholder-field="value"]';
                    var input = placeholderModalEl.querySelector(selector);
                    return {
                        id: entry.id,
                        token: entry.token,
                        label: entry.label,
                        value: input ? input.value : entry.value,
                    };
                });
                placeholderValues = updated;
                applyPlaceholderReplacements();
                closePlaceholderModal();
            });
        }
        placeholderModalBackdropHandler = function(event){
            if (event.target === placeholderModalEl) {
                closePlaceholderModal();
            }
        };
        placeholderModalEl.addEventListener('click', placeholderModalBackdropHandler);
        document.addEventListener('keydown', handlePlaceholderEsc);
        if (focusTarget) {
            requestAnimationFrame(function(){
                focusTarget.focus();
                focusTarget.select();
            });
        }
    }

    function updatePlaceholderButtonLabel(){
        if (!placeholderToggleBtn) return;
        if (!placeholderEntries.length) {
            placeholderToggleBtn.style.display = 'none';
            placeholderToggleBtn.setAttribute('aria-hidden', 'true');
            placeholderToggleBtn.disabled = true;
            return;
        }
        placeholderToggleBtn.style.display = '';
        placeholderToggleBtn.removeAttribute('aria-hidden');
        placeholderToggleBtn.disabled = false;
        var label = vt('placeholderButton', placeholderToggleBtn.textContent || '');
        if (label) {
            placeholderToggleBtn.textContent = label;
        }
        var title = vt('placeholderButtonTitle', placeholderToggleBtn.title || label || '');
        if (title) {
            placeholderToggleBtn.title = title;
        }
    }

    function applyPlaceholderReplacements(){
        if (!main) return;
        var replacements = placeholderValues
            .filter(function(entry){
                return entry && entry.token;
            })
            .map(function(entry){
                return {
                    token: String(entry.token),
                    value:
                        entry.value == null
                            ? ''
                            : String(entry.value),
                };
            })
            .filter(function(entry){
                return entry.token && entry.value.length;
            });
        var nextHtml = replacements.length
            ? buildContentWithPlaceholders(originalMainHtml, replacements)
            : originalMainHtml;
        main.innerHTML = nextHtml;
        normalizeViewerInlineTextColors(main);

        if (Array.isArray(headings) && Array.isArray(originalHeadings)) {
            originalHeadings.forEach(function(base, index){
                if (!headings[index]) return;
                headings[index].text = replaceTokensInString(base.text || '', replacements);
            });
        }

        if (Array.isArray(npcs) && Array.isArray(originalNpcs)) {
            var updatedNpcs = originalNpcs.map(function(base){
                if (!base) return base;
                var clone = JSON.parse(JSON.stringify(base));
                clone.name = replaceTokensInString(clone.name || '', replacements);
                clone.shortDescription = replaceTokensInString(clone.shortDescription || '', replacements);
                clone.description = replaceTokensInString(clone.description || '', replacements);
                clone.profile = replaceTokensInString(clone.profile || '', replacements);
                clone.commands = replaceTokensInString(clone.commands || '', replacements);
                if (Array.isArray(clone.stats)) {
                    clone.stats = clone.stats.map(function(entry){
                        if (!entry) return entry;
                        return {
                            label: replaceTokensInString(entry.label || '', replacements),
                            value: replaceTokensInString(entry.value || '', replacements),
                            max: replaceTokensInString(entry.max || '', replacements),
                        };
                    });
                }
                if (Array.isArray(clone.customStatus)) {
                    clone.customStatus = clone.customStatus.map(function(entry){
                        if (!entry) return entry;
                        return {
                            label: replaceTokensInString(entry.label || '', replacements),
                            value: replaceTokensInString(entry.value || '', replacements),
                            max: replaceTokensInString(entry.max || '', replacements),
                        };
                    });
                }
                if (Array.isArray(clone.customParams)) {
                    clone.customParams = clone.customParams.map(function(entry){
                        if (!entry) return entry;
                        return {
                            label: replaceTokensInString(entry.label || '', replacements),
                            value: replaceTokensInString(entry.value || '', replacements),
                        };
                    });
                }
                return clone;
            });
            npcs.length = 0;
            Array.prototype.push.apply(npcs, updatedNpcs);
        }

        if (Array.isArray(npcGroups) && Array.isArray(originalNpcGroups)) {
            var updatedGroups = originalNpcGroups.map(function(base){
                if (!base) return base;
                var clone = JSON.parse(JSON.stringify(base));
                clone.name = replaceTokensInString(clone.name || '', replacements);
                return clone;
            });
            npcGroups.length = 0;
            Array.prototype.push.apply(npcGroups, updatedGroups);
        }

        if (typeof dialogueCountByNpc === 'object' && dialogueCountByNpc !== null) {
            Object.keys(dialogueCountByNpc).forEach(function(key){
                delete dialogueCountByNpc[key];
            });
            Array.from(main.querySelectorAll('.npc-dialogue')).forEach(function(el){
                var id = el.dataset ? el.dataset.npcId : null;
                if (!id) return;
                dialogueCountByNpc[id] = (dialogueCountByNpc[id] || 0) + 1;
            });
        }

        resolveDialogueIcons();
        ensureCopyButtons(main);
        refreshCopyButtonLabels(main);
        annotateLinks(main);
        splitPages();
        if (isPaged) {
            setPaginationVisibility(true);
            if (currentPage >= pages.length) {
                currentPage = Math.max(0, pages.length - 1);
            }
            renderPage(currentPage);
        } else {
            setPaginationVisibility(false);
            Array.from(main.children).forEach(function(el){
                el.classList.remove('page-hidden');
            });
            annotateLinks(main);
        }
        renderHeadingsTree();
        setupTocDepthOptions();
        renderNpcListExport();
        updateDialogueStyleLabel();
        updateRubyLabel();
        refreshCopyButtonLabels(main);
        updatePlaceholderButtonLabel();
    }

    updatePlaceholderButtonLabel();
    if (placeholderToggleBtn) {
        placeholderToggleBtn.addEventListener('click', openPlaceholderModal);
    }

    function clampNpcPanelWidth(value, fallback){
        if (typeof value === 'string') {
            value = parseFloat(value);
        }
        var numeric = Number(value);
        if (!Number.isFinite(numeric)) return fallback;
        if (numeric < NPC_PANEL_MIN_WIDTH) return NPC_PANEL_MIN_WIDTH;
        if (numeric > NPC_PANEL_MAX_WIDTH) return NPC_PANEL_MAX_WIDTH;
        return numeric;
    }

    function setNpcPanelWidth(width, force){
        var reference = Number.isFinite(npcPanelWidth) ? npcPanelWidth : NPC_PANEL_DEFAULT_WIDTH;
        var next = clampNpcPanelWidth(width, reference);
        if (!force && next === npcPanelWidth) return npcPanelWidth;
        npcPanelWidth = next;
        root.style.setProperty('--npc-panel-width', npcPanelWidth + 'px');
        return npcPanelWidth;
    }

    function beginNpcPanelResize(startX){
        isNpcPanelResizing = true;
        npcPanelResizeStartX = startX;
        npcPanelResizeStartWidth = npcPanelWidth;
        body.classList.add('npc-panel-resizing');
        if (npcPanelResizer) npcPanelResizer.classList.add('dragging');
    }

    function updateNpcPanelResize(currentX){
        if (!isNpcPanelResizing) return;
        var delta = npcPanelResizeStartX - currentX;
        setNpcPanelWidth(npcPanelResizeStartWidth + delta, true);
    }

    function finishNpcPanelResize(){
        if (!isNpcPanelResizing) return;
        isNpcPanelResizing = false;
        body.classList.remove('npc-panel-resizing');
        if (npcPanelResizer) npcPanelResizer.classList.remove('dragging');
        npcPanelResizeStartWidth = npcPanelWidth;
    }

    function handleNpcPanelResizerPointerDown(event){
        if (event.pointerType === 'mouse' && typeof event.button === 'number' && event.button !== 0) return;
        event.preventDefault();
        var pointerId = event.pointerId;
        beginNpcPanelResize(event.clientX);
        var moveHandler = function(moveEvent){
            if (moveEvent.pointerId !== pointerId) return;
            moveEvent.preventDefault();
            updateNpcPanelResize(moveEvent.clientX);
        };
        var endHandler = function(endEvent){
            if (endEvent.pointerId !== pointerId) return;
            endEvent.preventDefault();
            finishNpcPanelResize();
            window.removeEventListener('pointermove', moveHandler);
            window.removeEventListener('pointerup', endHandler);
            window.removeEventListener('pointercancel', endHandler);
        };
        window.addEventListener('pointermove', moveHandler);
        window.addEventListener('pointerup', endHandler);
        window.addEventListener('pointercancel', endHandler);
    }

    function handleNpcPanelResizerKeydown(event){
        if (!npcPanelResizer) return;
        var step = event.shiftKey ? 20 : 10;
        var prev = npcPanelWidth;
        if (event.key === 'ArrowLeft') {
            setNpcPanelWidth(npcPanelWidth + step, true);
        } else if (event.key === 'ArrowRight') {
            setNpcPanelWidth(npcPanelWidth - step, true);
        } else if (event.key === 'Home') {
            setNpcPanelWidth(NPC_PANEL_MAX_WIDTH, true);
        } else if (event.key === 'End') {
            setNpcPanelWidth(NPC_PANEL_MIN_WIDTH, true);
        } else {
            return;
        }
        if (npcPanelWidth !== prev) {
            npcPanelResizeStartWidth = npcPanelWidth;
        }
        event.preventDefault();
    }

    if (settings && settings.headingStyles) {
        const hs = settings.headingStyles;
        ['p','h1','h2','h3','h4','h5','h6'].forEach(function(lv){
            const s = hs[lv];
            if (!s) return;
        if (lv === 'p') {
            if (s.color) root.style.setProperty('--p-color', s.color);
            if (s.bg) root.style.setProperty('--p-bg', s.bg);
            if (s.font) root.style.setProperty('--p-font', s.font);
            if (s.size) root.style.setProperty('--p-font-size', s.size);
            if (s.lineHeight) root.style.setProperty('--p-line-height', s.lineHeight);
        } else {
                if (s.color) root.style.setProperty('--' + lv + '-color', s.color);
                if (s.bg) root.style.setProperty('--' + lv + '-bg', s.bg);
                if (s.font) root.style.setProperty('--' + lv + '-font', s.font);
                if (s.size) root.style.setProperty('--' + lv + '-size', s.size);
                if (s.underlineColor) root.style.setProperty('--' + lv + '-ul-color', s.underlineColor);
                if (s.underlineWidth) root.style.setProperty('--' + lv + '-ul-width', s.underlineWidth);
                if (s.underlineStyle) root.style.setProperty('--' + lv + '-ul-style', s.underlineStyle);
            }
        });
    }

    // Resolve character icons in dialogues from character data (avoid per-message images)
    function resolveDialogueIcons() {
        main.querySelectorAll('.npc-dialogue').forEach(block => {
            const icon = block.querySelector('.npc-icon');
            if (!icon) return;
            const npcId = block.dataset.npcId;
            const exp = block.dataset.expressionName;
            const npc = npcId
                ? npcs.find(n => String(n.id) === String(npcId))
                : null;
            if (npc) {
                const img = (npc.images || []).find(im => im.name === exp) || (npc.images || [])[0];
                if (img && img.src) {
                    icon.src = img.src;
                } else if (isFreeNameNpc(npc) && PLACEHOLDER_ICON) {
                    icon.src = PLACEHOLDER_ICON;
                }
                if (npc.borderColor) icon.style.borderColor = npc.borderColor;
                const bubble = block.querySelector('.npc-bubble');
                if (bubble && npc.bubbleColor) bubble.style.setProperty('--bubble-bg', npc.bubbleColor);
                block.style.setProperty('--speaker-color', npc.borderColor || '#1f2937');
                if (!icon.getAttribute('alt') || !icon.getAttribute('alt').trim()) {
                    icon.setAttribute('alt', npc.name || 'NPC');
                }
            } else if (PLACEHOLDER_ICON) {
                const currentSrc = icon.getAttribute('src');
                if (!currentSrc || !currentSrc.trim()) {
                    icon.src = PLACEHOLDER_ICON;
                }
                if (!icon.getAttribute('alt') || !icon.getAttribute('alt').trim()) {
                    const fallbackName = block.dataset.npcName || '';
                    icon.setAttribute('alt', fallbackName || 'NPC');
                }
            }
        });
    }

    function getRegisteredExpressionName(block) {
        if (!block || !block.dataset) return '';
        const raw = (block.dataset.expressionName || '').trim();
        if (!raw) return '';
        const npcId = block.dataset.npcId;
        if (!npcId) return '';
        const npc = npcs.find((candidate) => {
            if (!candidate) return false;
            if (candidate.id == null && npcId == null) return false;
            return String(candidate.id) === String(npcId);
        });
        if (!npc || !Array.isArray(npc.images)) return '';
        const match = npc.images.find((img) => {
            if (!img) return false;
            const name = typeof img.name === 'string' ? img.name.trim() : '';
            return name === raw;
        });
        if (!match) return '';
        return raw;
    }

    resolveDialogueIcons();
    ensureCopyButtons(main);
    refreshCopyButtonLabels(main);
    annotateLinks(main);
    const copyObserver = new MutationObserver(function(mutations){
        var needsUpdate = false;
        for (var i = 0; i < mutations.length; i++) {
            var m = mutations[i];
            if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
                needsUpdate = true;
                break;
            }
        }
        if (needsUpdate) {
            requestAnimationFrame(function(){
                ensureCopyButtons(main);
                refreshCopyButtonLabels(main);
                annotateLinks(main);
            });
        }
    });
    copyObserver.observe(main, { childList: true, subtree: true });

    function updateExpressionTagLabel() {
        if (!expressionTagToggle) return;
        const label = isExpressionTagEnabled
            ? vt('expressionTagOn', expressionTagToggle.textContent)
            : vt('expressionTagOff', expressionTagToggle.textContent);
        expressionTagToggle.textContent = label;
        expressionTagToggle.title = label;
        expressionTagToggle.setAttribute('aria-label', label);
        expressionTagToggle.classList.toggle('active', isExpressionTagEnabled);
        if (body) {
            body.classList.toggle('expression-tag-enabled', isExpressionTagEnabled);
        }
    }

    // Panel Logic
    if (toggleHeadingsBtn) {
        toggleHeadingsBtn.addEventListener('click', () => {
            headingsPanel.classList.toggle('closed');
            body.classList.toggle('headings-closed');
        });
    }
    if (toggleNpcsBtn) {
        toggleNpcsBtn.addEventListener('click', () => {
            npcPanel.classList.toggle('closed');
            body.classList.toggle('npcs-open');
        });
    }

    if (npcPanelResizer) {
        npcPanelResizer.addEventListener('pointerdown', handleNpcPanelResizerPointerDown);
        npcPanelResizer.addEventListener('keydown', handleNpcPanelResizerKeydown);
    }



    // Populate Panels
    const headingsList = document.getElementById('headings-list-export');
    const tocDepthSelect = document.getElementById('toc-depth-select');
    const headingCollapseState = new Map();
    let tocDepthSelectInitialized = false;

    const availableHeadingLevels = Array.isArray(headings)
        ? headings.reduce((max, entry) => {
              const lvl = Number(entry && entry.level);
              if (!Number.isFinite(lvl)) return max;
              const clamped = Math.min(Math.max(Math.round(lvl), 1), 6);
              return clamped > max ? clamped : max;
          }, 0)
        : 0;

    function clampHeadingLevelForToc(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
            return availableHeadingLevels || 1;
        }
        const rounded = Math.max(1, Math.min(6, Math.round(numeric)));
        return availableHeadingLevels
            ? Math.min(rounded, availableHeadingLevels)
            : rounded;
    }

    let tocDepthLimit = clampHeadingLevelForToc(
        settings && settings.tocMaxLevel ? settings.tocMaxLevel : availableHeadingLevels || 1
    );

    function buildHeadingTree(maxLevel) {
        if (!Array.isArray(headings) || !headings.length) return [];
        const root = { level: 0, children: [] };
        const stack = [root];
        headings.forEach((entry) => {
            if (!entry) return;
            const rawLevel = clampHeadingLevelForToc(entry.level);
            if (rawLevel > maxLevel) return;
            const text = entry.text == null ? '' : String(entry.text).trim();
            if (!entry.id || !text) return;
            while (stack.length > 1 && stack[stack.length - 1].level >= rawLevel) {
                stack.pop();
            }
            const parent = stack[stack.length - 1];
            const node = {
                id: entry.id,
                text: text,
                level: rawLevel,
                children: [],
            };
            parent.children.push(node);
            stack.push(node);
        });
        return root.children;
    }

    function renderHeadingNodes(nodes, container) {
        nodes.forEach((node) => {
            const li = document.createElement('li');
            li.className = 'toc-node';
            li.dataset.level = String(node.level);
            if (node.children.length) {
                li.classList.add('has-children');
            }
            const isCollapsed = headingCollapseState.get(node.id) === true;
            if (isCollapsed) {
                li.classList.add('collapsed');
            }

            const row = document.createElement('div');
            row.className = 'toc-row';

            const toggle = document.createElement('button');
            toggle.type = 'button';
            toggle.className = 'toc-toggle';
            if (node.children.length) {
            const expandLabel = vt('tocExpand', 'Expand');
            const collapseLabel = vt('tocCollapse', 'Collapse');
            toggle.setAttribute('aria-label', isCollapsed ? expandLabel : collapseLabel);
                toggle.setAttribute('aria-expanded', String(!isCollapsed));
                toggle.textContent = isCollapsed ? 'â–¸' : 'â–¾';
            } else {
                toggle.classList.add('is-placeholder');
                toggle.setAttribute('aria-hidden', 'true');
                toggle.tabIndex = -1;
                toggle.textContent = '';
            }

            toggle.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                if (!node.children.length) return;
                headingCollapseState.set(node.id, !isCollapsed);
                renderHeadingsTree();
            });

            const link = document.createElement('a');
            link.href = '#' + node.id;
            link.textContent = node.text || node.id;

            row.appendChild(toggle);
            row.appendChild(link);
            li.appendChild(row);

            if (node.children.length) {
                const childUl = document.createElement('ul');
                renderHeadingNodes(node.children, childUl);
                li.appendChild(childUl);
            }

            container.appendChild(li);
        });
    }

    function renderHeadingsTree() {
        if (!headingsList) return;
        headingsList.innerHTML = '';
        const tree = buildHeadingTree(tocDepthLimit);
        if (!tree.length) {
            const emptyText = vt('tocEmpty', 'No headings');
            headingsList.innerHTML = '<li class="no-headings">' + esc(emptyText) + '</li>';
            if (tocDepthSelect) {
                tocDepthSelect.disabled = true;
            }
            return;
        }
        renderHeadingNodes(tree, headingsList);
        if (tocDepthSelect) {
            tocDepthSelect.disabled = availableHeadingLevels <= 1;
        }
        annotateLinks(headingsList);
    }

    function setupTocDepthOptions() {
        if (!tocDepthSelect) return;
        tocDepthSelect.innerHTML = '';
        if (!availableHeadingLevels) {
            tocDepthSelect.disabled = true;
            return;
        }
        for (let level = 1; level <= availableHeadingLevels; level += 1) {
            const option = document.createElement('option');
            option.value = String(level);
            option.textContent = vt(
                'tocLevelOption',
                'H' + level,
                { level: level },
            );
            tocDepthSelect.appendChild(option);
        }
        tocDepthSelect.value = String(tocDepthLimit);
        tocDepthSelect.disabled = availableHeadingLevels <= 1;
        if (!tocDepthSelectInitialized) {
            tocDepthSelect.addEventListener('change', () => {
                const next = clampHeadingLevelForToc(tocDepthSelect.value);
                if (next === tocDepthLimit) return;
                tocDepthLimit = next;
                renderHeadingsTree();
            });
            tocDepthSelectInitialized = true;
        }
    }

    setupTocDepthOptions();
    renderHeadingsTree();
    const npcList = document.getElementById('npc-list-export');
    const npcGroupState = {};
    if (Array.isArray(npcGroups)) {
        npcGroups.forEach(group => {
            if (!group || group.id == null) return;
            npcGroupState[String(group.id)] = Boolean(group.collapsed);
        });
    }
    // Pre-compute dialogue count per character
    const dialogueCountByNpc = {};
    Array.from(main.querySelectorAll('.npc-dialogue')).forEach(el => {
        const id = el.dataset.npcId;
        if (!id) return;
        dialogueCountByNpc[id] = (dialogueCountByNpc[id] || 0) + 1;
    });
    let isPaged = false;
    let currentPage = 0;
    let pages = [];
    let elementPageIndex = new WeakMap();
    let isRubyVisible = true;
    let isExpressionTagEnabled = false;

    function buildNpcItemHtml(npc) {
        if (!npc) return '';
        const imagesArr = Array.isArray(npc.images) ? npc.images : [];
        const img = imagesArr.find(i => (i.name || '').toLowerCase() === 'default') || imagesArr[0];
        let src = img && img.src ? img.src : '';
        if (!src && isFreeNameNpc(npc) && PLACEHOLDER_ICON) {
            src = PLACEHOLDER_ICON;
        }
        const name = esc(npc.name || '');
        const fullDesc = npc.description || npc.profile || '';
        const firstLine = (String(fullDesc)
            .replace(/\r\n|\r|\n/g, '\n')
            .split('\n')
            .find(Boolean) || '');
        const shortDesc = (npc.shortDescription && npc.shortDescription.trim())
            ? npc.shortDescription.trim()
            : (firstLine.length > 80 ? firstLine.slice(0, 80) + 'â€¦' : firstLine);
        const profShort = esc(shortDesc);
        const border = npc.borderColor || '';
        const accent = border ? esc(border) : '#c7d2fe';
        const count = dialogueCountByNpc[npc.id] || 0;
        const badgeLabel = count
            ? vt('dialogueBadge', 'Dialogue {{count}}', { count: count })
            : '';
        const convBadge = count
            ? '<span class="npc-conv">' + esc(badgeLabel) + '</span>'
            : '';
        const jsonTitle = vt('copyJsonTitle', 'Copy JSON for CCFOL');
        return '<div class="npc-item-export" data-npc-id="' + esc(npc.id || '') + '" style="--npc-accent:' + accent + ';">'
            + '<img src="' + src + '" alt="' + name + '" referrerpolicy="no-referrer" style="border-color:' + accent + '">'
            + '<div class="npc-meta">'
            +   '<div class="npc-header"><strong class="npc-name">' + name + '</strong>'
            +   convBadge
            +   '<button class="npc-ccfol-btn button-pill button-pill-secondary button-pill-compact" type="button" title="' + esc(jsonTitle) + '" aria-label="' + esc(jsonTitle) + '">JSON</button>'
            +   '</div>'
            +   (profShort ? '<div class="npc-profile">' + profShort + '</div>' : '')
            + '</div>'
        + '</div>';
    }

    function renderNpcListExport() {
        if (!npcList) return;
        if (npcs.length === 0) {
            npcList.innerHTML = '<p>' + esc(vt('npcEmpty', 'No characters')) + '</p>';
            return;
        }
        const npcMap = new Map(npcs.map(npc => [String(npc.id), npc]));
        let groups = Array.isArray(npcGroups) && npcGroups.length
            ? npcGroups.map(group => {
                  const id = String(group && group.id != null ? group.id : '');
                  const order = Array.isArray(group && group.npcOrder)
                      ? group.npcOrder.map(id => String(id))
                      : [];
                  const name = group && group.name ? String(group.name) : vt('npcGroupDefault', 'Characters');
                  const collapsed = Object.prototype.hasOwnProperty.call(
                      npcGroupState,
                      id,
                  )
                      ? npcGroupState[id]
                      : Boolean(group && group.collapsed);
                  npcGroupState[id] = collapsed;
                  return { id, name, collapsed, npcOrder: order };
              })
            : [];
        if (!groups.length) {
            groups = [
                {
                    id: 'viewer-default',
                    name: vt('npcGroupDefault', 'Characters'),
                    collapsed: false,
                    npcOrder: Array.from(npcMap.keys()),
                },
            ];
        }
        const assigned = new Set();
        groups.forEach((group) => {
            group.npcOrder = group.npcOrder.filter((id) => npcMap.has(id));
            group.npcOrder.forEach((id) => assigned.add(id));
        });
        const fallback = groups[0];
        if (fallback) {
            if (!Object.prototype.hasOwnProperty.call(npcGroupState, fallback.id)) {
                npcGroupState[fallback.id] = Boolean(fallback.collapsed);
            }
            npcMap.forEach((_, id) => {
                if (!assigned.has(id)) fallback.npcOrder.push(id);
            });
        }
        npcList.innerHTML = groups
            .map((group) => {
                const items = group.npcOrder
                    .map((id) => buildNpcItemHtml(npcMap.get(id)))
                    .filter(Boolean)
                    .join('');
                const emptyHtml = '<p class="npc-group-empty-export">' + esc(vt('npcGroupEmpty', 'No characters')) + '</p>';
                const bodyHtml = items || emptyHtml;
                const safeName = esc(group.name || vt('npcGroupDefault', 'Characters'));
                const collapsedClass = group.collapsed ? ' collapsed' : '';
                const count = group.npcOrder.length;
                return (
                    '<div class="npc-group-export' +
                    collapsedClass +
                    '" data-group-id="' +
                    esc(group.id || '') +
                    '">' +
                    '<div class="npc-group-header-export">' +
                    '<button type="button" class="npc-group-toggle-export" aria-expanded="' +
                    (!group.collapsed) +
                    '">' +
                    (group.collapsed ? 'â–¶' : 'â–¼') +
                    '</button>' +
                    '<span class="npc-group-title-export">' +
                    safeName +
                    '</span>' +
                    '<span class="npc-group-count-export">' +
                    count +
                    '</span>' +
                    '</div>' +
                    '<div class="npc-group-body-export">' +
                    bodyHtml +
                    '</div>' +
                    '</div>'
                );
            })
            .join('');
    }

    function getAvailableViewerLanguages() {
        const codes = [];
        if (viewerLanguageBundles && typeof viewerLanguageBundles === 'object') {
            Object.keys(viewerLanguageBundles).forEach((code) => {
                if (viewerLanguageBundles[code]) codes.push(code);
            });
        }
        if (!codes.length) {
            const fallback = viewerText && viewerText.lang ? viewerText.lang : viewerDefaultLanguage;
            codes.push(fallback);
        }
        return codes;
    }

    function renderLanguageOptions() {
        if (!viewerLanguageSelect) return;
        const codes = getAvailableViewerLanguages();
        viewerLanguageSelect.innerHTML = '';
        const labels = (activeViewerText && activeViewerText.languageOptions) || {};
        codes.forEach((code) => {
            const option = document.createElement('option');
            option.value = code;
            option.textContent = labels[code] || code;
            viewerLanguageSelect.appendChild(option);
        });
        viewerLanguageSelect.value = currentViewerLanguage;
        viewerLanguageSelect.disabled = codes.length <= 1;
        const aria = vt('languageAria', viewerLanguageSelect.getAttribute('aria-label') || '');
        if (aria) viewerLanguageSelect.setAttribute('aria-label', aria);
    }

    function refreshStaticViewerLabels() {
        if (toggleHeadingsBtn) {
            toggleHeadingsBtn.title = vt('tocToggleTitle', toggleHeadingsBtn.title || '');
            toggleHeadingsBtn.textContent = vt('tocToggleLabel', toggleHeadingsBtn.textContent);
        }
        if (tocTitleEl) {
            tocTitleEl.textContent = vt('tocTitle', tocTitleEl.textContent);
        }
        if (tocDepthLabelEl) {
            tocDepthLabelEl.textContent = vt('tocDepthLabel', tocDepthLabelEl.textContent);
        }
        if (tocDepthSelect) {
            const aria = vt('tocDepthAria', tocDepthSelect.getAttribute('aria-label') || '');
            if (aria) tocDepthSelect.setAttribute('aria-label', aria);
        }
        if (toggleNpcsBtn) {
            toggleNpcsBtn.title = vt('npcToggleTitle', toggleNpcsBtn.title || '');
            toggleNpcsBtn.textContent = vt('npcToggleLabel', toggleNpcsBtn.textContent);
        }
        if (npcPanelHeadingEl) {
            npcPanelHeadingEl.textContent = vt('npcPanelHeading', npcPanelHeadingEl.textContent);
        }
        if (npcPanelResizer) {
            const aria = vt('resizerAria', npcPanelResizer.getAttribute('aria-label') || '');
            if (aria) npcPanelResizer.setAttribute('aria-label', aria);
        }
        if (viewerLanguageLabelEl) {
            viewerLanguageLabelEl.textContent = vt('languageLabel', viewerLanguageLabelEl.textContent);
        }
        if (viewerLanguageSelect) {
            const aria = vt('languageAria', viewerLanguageSelect.getAttribute('aria-label') || '');
            if (aria) viewerLanguageSelect.setAttribute('aria-label', aria);
        }
        if (themeToggleBtn) {
            const title = vt('themeToggleTitle', themeToggleBtn.getAttribute('title') || '');
            if (title) {
                themeToggleBtn.setAttribute('title', title);
                themeToggleBtn.setAttribute('aria-label', title);
            }
            refreshThemeToggleLabel(themePreference);
        }
        if (expressionTagToggle) {
            updateExpressionTagLabel();
        }
        if (placeholderToggleBtn) {
            updatePlaceholderButtonLabel();
        }
    }

    function refreshCopyButtonLabels(scope) {
        const label = vt('copyButtonTitle', 'Copy to clipboard');
        (scope || document).querySelectorAll('.copy-btn-export').forEach((btn) => {
            btn.title = label;
            btn.setAttribute('aria-label', label);
        });
    }

    function applyViewerLanguage(lang, { persist = true } = {}) {
        const target = normalizeViewerLanguage(lang);
        currentViewerLanguage = target;
        activeViewerText = getViewerBundle(target);
        if (persist && typeof localStorage !== 'undefined') {
            try {
                localStorage.setItem(VIEWER_LANGUAGE_STORAGE_KEY, target);
            } catch (_) {}
        }
        if (root) {
            root.setAttribute('lang', activeViewerText.lang || target);
        }
        refreshStaticViewerLabels();
        renderLanguageOptions();
        refreshCopyButtonLabels(document);
        setupTocDepthOptions();
        renderHeadingsTree();
        renderNpcListExport();
        updateViewModeLabel();
        updateDialogueStyleLabel();
        if (typeof updateExpressionTagLabel === 'function') {
            updateExpressionTagLabel();
        }
        if (typeof updateRubyLabel === 'function') {
            updateRubyLabel();
        }
        updatePaginationUi(currentPage);
    }

    if (viewerLanguageSelect) {
        viewerLanguageSelect.addEventListener('change', (event) => {
            applyViewerLanguage(event.target.value);
        });
    }

    if (npcList) {
        renderNpcListExport();
        if (shouldAutoApplyPlaceholders) {
            applyPlaceholderReplacements();
        }
        npcList.addEventListener('click', function (e) {
            const toggleBtn = e.target.closest('.npc-group-toggle-export');
            if (toggleBtn) {
                const groupEl = toggleBtn.closest('.npc-group-export');
                if (groupEl) {
                    const groupId = groupEl.getAttribute('data-group-id') || '';
                    const collapsed = groupEl.classList.toggle('collapsed');
                    toggleBtn.textContent = collapsed ? 'â–¶' : 'â–¼';
                    toggleBtn.setAttribute('aria-expanded', String(!collapsed));
                    if (groupId) npcGroupState[groupId] = collapsed;
                }
                return;
            }
            const jsonBtn = e.target.closest('.npc-ccfol-btn');
            if (jsonBtn) {
                const item = jsonBtn.closest('.npc-item-export');
                const id = item && item.getAttribute('data-npc-id');
                if (id) copyCcfolForNpc(id, jsonBtn);
                return;
            }
            const item = e.target.closest('.npc-item-export');
            if (!item) return;
            const id = item.getAttribute('data-npc-id');
            if (id) openNpcDetail(id);
        });
    }

    function nl2br(s){ return esc(s||'').replace(/\r\n|\r|\n/g,'<br>'); }

    function openNpcDetail(id){
        const npc = npcs.find(n=>String(n.id)===String(id));
        if(!npc) return;
        const modal = document.getElementById('npc-detail-modal');
        const box = modal.querySelector('.modal-content');
        const imagesArr = Array.isArray(npc.images) ? npc.images : [];
        const img = imagesArr.find(i => (i.name||'').toLowerCase()==='default') || imagesArr[0];
        let src = img && img.src ? img.src : '';
        if (!src && isFreeNameNpc(npc) && PLACEHOLDER_ICON) {
            src = PLACEHOLDER_ICON;
        }
        const stats = npc.stats || {};
        const statusEntries = [];
        const paramEntries = [];
        const customStatus = npc.customStatus || null;

        if (customStatus) {
            if (Array.isArray(customStatus.statuses)) {
                customStatus.statuses.forEach((item) => {
                    if (!item) return;
                    const label = (item.label || "").trim();
                    const value = (item.value || "").trim();
                    const max = (item.max || "").trim();
                    if (!label) return;
                    if (!value && !max) return;
                    let display = "";
                    if (value && max) {
                        display = value + " / " + max;
                    } else if (value) {
                        display = value;
                    } else {
                        display = max;
                    }
                    statusEntries.push({
                        label,
                        value: display,
                    });
                });
            }
            if (Array.isArray(customStatus.params)) {
                customStatus.params.forEach((item) => {
                    if (!item) return;
                    const label = (item.label || "").trim();
                    const value = (item.value || "").trim();
                    if (!label) return;
                    paramEntries.push({
                        label,
                        value,
                    });
                });
            }
        }

        if (!statusEntries.length && !paramEntries.length) {
            Object.keys(stats).forEach((key) => {
                const value = stats[key];
                if (value == null) return;
                const text = String(value).trim();
                if (!text) return;
                const entry = { label: key, value: text };
                if (text.includes("/")) {
                    statusEntries.push(entry);
                } else {
                    paramEntries.push(entry);
                }
            });
        }

        const initiativeDisplay = (() => {
            const customInit = customStatus
                ? toNum(customStatus.initiative)
                : undefined;
            const manualInit = toNum(npc.initiative);
            if (typeof customInit !== "undefined") return customInit;
            if (typeof manualInit !== "undefined") return manualInit;
            return "";
        })();
        const noneLabel = vt('npcNone', 'None');
        const notSetLabel = vt('npcNotSet', 'Not set');
        const initiativeLabel = vt('npcInitiative', 'Initiative');
        const briefHeading = vt('npcBriefHeading', 'Summary');
        const detailHeading = vt('npcDetailHeading', 'Detailed Description');
        const statusHeading = vt('npcStatusHeading', 'Status');
        const paramsHeading = vt('npcParamsHeading', 'Parameters');
        const commandsHeading = vt('npcCommandsHeading', 'Chat Palette');
        const commandsCopyLabel = vt('npcCommandsCopy', 'Copy');
        const jsonTitle = vt('copyJsonTitle', 'Copy JSON for CCFOL');
        const modalCloseLabel = vt('modalClose', 'Close');
        const renderEntryGrid = (entries) =>
            entries.length
                ? '<div class="stat-grid">' +
                  entries
                      .map(
                          (entry) =>
                              '<div class="stat-item"><strong>' +
                              esc(entry.label) +
                              '</strong> ' +
                              esc(entry.value) +
                              "</div>",
                      )
                      .join("") +
                  "</div>"
                : '<div class="viewer-text-muted">' + esc(noneLabel) + '</div>';
        const statusHtml = renderEntryGrid(statusEntries);
        const paramsHtml = renderEntryGrid(paramEntries);
        const hasInitiative =
            initiativeDisplay !== "" &&
            initiativeDisplay !== null &&
            initiativeDisplay !== undefined;
        const initiativeHtml =
            '<div class="stat-meta" style="margin-top:8px;">' +
            esc(initiativeLabel) +
            ': ' +
            (hasInitiative
                ? esc(String(initiativeDisplay))
                : '<span class="viewer-text-muted">' + esc(notSetLabel) + '</span>') +
            '</div>';
        const commands = npc.commands || '';
        const shortDesc = npc && typeof npc.shortDescription === 'string'
            ? npc.shortDescription.replace(/\r\n?/g, '\n').trim()
            : '';
        const shortDescHtml = shortDesc
            ? nl2br(shortDesc)
            : '<span class="viewer-text-muted">' + esc(notSetLabel) + '</span>';
        const heroSection = src
            ? '<section class="hero"><img src="' + src + '" alt="' + esc(npc.name||'') + '" referrerpolicy="no-referrer"><div><div class="section-title">' + esc(briefHeading) + '</div>' + shortDescHtml + '</div></section>'
            : '<section><div class="section-title">' + esc(briefHeading) + '</div>' + shortDescHtml + '</section>';
        const commandsSection = commands
            ? '<pre class="commands">' + esc(commands) + '</pre><button class="npc-cmd-copy" type="button">' + esc(commandsCopyLabel) + '</button>'
            : '<div class="viewer-text-muted">' + esc(noneLabel) + '</div>';
        box.innerHTML = [
            '<div class="modal-header">',
                '<h2>' + esc(npc.name||'') + '</h2>',
                '<div>',
                    '<button class="npc-ccfol-btn button-pill button-pill-secondary button-pill-compact modal-close-json" type="button" data-npc-id="' + esc(npc.id||'') + '" title="' + esc(jsonTitle) + '" aria-label="' + esc(jsonTitle) + '">JSON</button>',
                    '<button class="modal-close" type="button" id="npc-detail-close">' + esc(modalCloseLabel) + '</button>',
                '</div>',
            '</div>',
            '<div class="detail-body">',
                heroSection,
                '<section>',
                    '<div class="section-title">' + esc(detailHeading) + '</div>',
                    nl2br(npc.description||''),
                '</section>',
                '<section>',
                    '<div class="section-title">' + esc(statusHeading) + '</div>',
                    statusHtml,
                    initiativeHtml,
                '</section>',
                '<section>',
                    '<div class="section-title">' + esc(paramsHeading) + '</div>',
                    paramsHtml,
                '</section>',
                '<section>',
                    '<div class="section-title">' + esc(commandsHeading) + '</div>',
                    commandsSection,
                '</section>',
            '</div>'
        ].join('');
        modal.classList.add('show');
        // bind close and copy
        box.querySelector('#npc-detail-close').addEventListener('click', closeNpcDetail);
        modal.addEventListener('click', function onbg(e){ if(e.target===modal) { modal.removeEventListener('click', onbg); closeNpcDetail(); } });
        const copyBtn = box.querySelector('.npc-cmd-copy');
        if (copyBtn) { copyBtn.addEventListener('click', ()=>{ copyText(commands, copyBtn); }); }
        const jsonBtn = box.querySelector('.modal-close-json');
        if (jsonBtn) { jsonBtn.addEventListener('click', ()=> copyCcfolForNpc(npc.id, jsonBtn)); }
    }
    function closeNpcDetail(){ document.getElementById('npc-detail-modal').classList.remove('show'); }
    function copyText(text, btn){
        if (!text) return;
        const successLabel = vt('copyButtonSuccess', 'Copied!');
        const showSuccess = () => {
            if (!btn) return;
            const original = btn.dataset.originalLabel || btn.textContent;
            btn.dataset.originalLabel = original;
            btn.textContent = successLabel;
            setTimeout(() => {
                btn.textContent = btn.dataset.originalLabel || original;
            }, 1000);
        };
        const fallback = () => {
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            showSuccess();
        };
        try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(showSuccess).catch(fallback);
            } else {
                fallback();
            }
        } catch (_) {
            fallback();
        }
    }

    function deriveCcfolSections(npc){
        const stats = npc && npc.stats ? npc.stats : {};
        const customStatus =
            npc && typeof npc.customStatus === 'object' ? npc.customStatus : null;
        const status = [];
        const params = [];
        const hasCustomData =
            customStatus &&
            ((Array.isArray(customStatus.statuses) && customStatus.statuses.length > 0) ||
             (Array.isArray(customStatus.params) && customStatus.params.length > 0));
        if (hasCustomData) {
            if (Array.isArray(customStatus.statuses)) {
                customStatus.statuses.forEach(item => {
                    if (!item) return;
                    const label = (item.label || '').trim();
                    if (!label) return;
                    const valueNum = toNum(item.value);
                    const hasMax =
                        item.max !== undefined &&
                        item.max !== null &&
                        String(item.max).trim() !== '';
                    const maxNum = hasMax ? toNum(item.max) : undefined;
                    if (
                        typeof valueNum === 'undefined' &&
                        typeof maxNum === 'undefined'
                    ) {
                        return;
                    }
                    const resolvedValue =
                        typeof valueNum !== 'undefined'
                            ? valueNum
                            : typeof maxNum !== 'undefined'
                                ? maxNum
                                : 0;
                    const resolvedMax =
                        typeof maxNum !== 'undefined'
                            ? maxNum
                            : resolvedValue;
                    status.push({
                        label,
                        value: resolvedValue,
                        max: resolvedMax
                    });
                });
            }
            if (Array.isArray(customStatus.params)) {
                customStatus.params.forEach(item => {
                    if (!item) return;
                    const label = (item.label || '').trim();
                    const value = (item.value || '').trim();
                    if (!label && !value) return;
                    params.push({
                        label,
                        value
                    });
                });
            }
        } else {
            Object.keys(stats).forEach(key => {
                const raw = stats[key];
                if (raw == null) return;
                const text = String(raw).trim();
                if (!text) return;
                if (text.includes('/')) {
                    const parts = text.split('/').map(p => toNum(p));
                    const valueNum = parts[0];
                    const maxNum = parts.length > 1 ? parts[1] : parts[0];
                    if (
                        typeof valueNum === 'undefined' &&
                        typeof maxNum === 'undefined'
                    ) {
                        params.push({ label: key, value: text });
                        return;
                    }
                    const resolvedValue =
                        typeof valueNum !== 'undefined'
                            ? valueNum
                            : typeof maxNum !== 'undefined'
                                ? maxNum
                                : 0;
                    const resolvedMax =
                        typeof maxNum !== 'undefined'
                            ? maxNum
                            : resolvedValue;
                    status.push({
                        label: key,
                        value: resolvedValue,
                        max: resolvedMax
                    });
                } else {
                    params.push({ label: key, value: text });
                }
            });
        }
        const manualInitiative = toNum(npc && npc.initiative);
        let initiative = 0;
        if (customStatus) {
            const customInit = toNum(customStatus.initiative);
            if (typeof customInit !== 'undefined') {
                initiative = customInit;
            } else if (typeof manualInitiative !== 'undefined') {
                initiative = manualInitiative;
            }
        } else if (typeof manualInitiative !== 'undefined') {
            initiative = manualInitiative;
        }
        return { status, params, initiative };
    }

    function composeCcfolCharacterPayload(npc){
        const sections = deriveCcfolSections(npc);
        const shortMemo =
            npc && typeof npc.shortDescription === 'string'
                ? npc.shortDescription.replace(/\r\n?/g, '\n').trim()
                : '';
        const memo =
            shortMemo && shortMemo.length
                ? shortMemo
                : String(npc && npc.description ? npc.description : '')
                      .replace(/\r\n?/g, '\n')
                      .split(/\n/)
                      .find(line => line && line.trim()) || '';
        return {
            kind: 'character',
            data: {
                name: npc && npc.name ? npc.name : '',
                memo,
                initiative: sections.initiative,
                externalUrl: '',
                status: sections.status,
                params: sections.params,
                color: npc && npc.borderColor ? npc.borderColor : '#888888',
                commands: npc && npc.commands ? npc.commands : ''
            }
        };
    }

    function toNum(v){
        if (v==null) return undefined; const n=parseFloat(String(v).replace(/[^0-9.+-]/g,'')); return Number.isFinite(n)?n:undefined;
    }
    function buildCcfolFromNpc(npc){
        return composeCcfolCharacterPayload(npc);
    }
    async function copyCcfolForNpc(id, btn){
        const npc = npcs.find(n=>String(n.id)===String(id));
        if(!npc) return; const payload = buildCcfolFromNpc(npc); const text = JSON.stringify(payload,null,2);
        const successLabel = vt('copyButtonSuccess', 'Copied!');
        const showSuccess = () => {
            if (!btn) return;
            const original = btn.dataset.originalLabel || btn.textContent;
            btn.dataset.originalLabel = original;
            btn.textContent = successLabel;
            setTimeout(() => {
                btn.textContent = btn.dataset.originalLabel || original;
            }, 1000);
        };
        const fallback = () => {
            const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); showSuccess();
        };
        try {
            if(navigator.clipboard && navigator.clipboard.writeText){
                await navigator.clipboard.writeText(text);
                showSuccess();
            } else {
                fallback();
            }
        } catch(_){
            fallback();
        }
    }

    function registerPageContent(content, pageIndex) {
        if (!content || !content.length) return;
        content.forEach(el => {
            elementPageIndex.set(el, pageIndex);
            if (el && el.dataset) {
                el.dataset.pageIndex = String(pageIndex);
            }
        });
    }

    function hasMeaningfulContent(node) {
        if (!node) return false;
        return Array.from(node.childNodes || []).some(child => {
            if (child.nodeType === 1) return true;
            if (child.nodeType === 3 && child.textContent && child.textContent.trim()) return true;
            return false;
        });
    }

    function pruneEmptyContainers(node) {
        if (!node || node === main) return;
        if (hasMeaningfulContent(node)) return;
        const parent = node.parentElement;
        if (!parent) return;
        parent.removeChild(node);
        pruneEmptyContainers(parent);
    }

    function promoteNestedPageBreak(breakEl) {
        if (!breakEl || breakEl.parentElement === main) return;
        let current = breakEl;
        while (current.parentElement && current.parentElement !== main) {
            const parent = current.parentElement;
            const clone = parent.cloneNode(false);
            if (clone && typeof clone.removeAttribute === 'function' && clone.hasAttribute('id')) {
                clone.removeAttribute('id');
            }
            if (clone && clone.hasAttribute && clone.hasAttribute('data-page-index')) {
                clone.removeAttribute('data-page-index');
            }
            if (clone && clone.dataset && Object.prototype.hasOwnProperty.call(clone.dataset, 'pageIndex')) {
                delete clone.dataset.pageIndex;
            }
            let sibling = current.nextSibling;
            let moved = false;
            while (sibling) {
                const next = sibling.nextSibling;
                clone.appendChild(sibling);
                sibling = next;
                moved = true;
            }
            if (moved && parent.parentElement) {
                parent.parentElement.insertBefore(clone, parent.nextSibling);
            }
            current = parent;
        }
        const parent = breakEl.parentElement;
        if (!parent) return;
        const remainder = parent.cloneNode(false);
        if (remainder && typeof remainder.removeAttribute === 'function' && remainder.hasAttribute('id')) {
            remainder.removeAttribute('id');
        }
        if (remainder && remainder.hasAttribute && remainder.hasAttribute('data-page-index')) {
            remainder.removeAttribute('data-page-index');
        }
        if (remainder && remainder.dataset && Object.prototype.hasOwnProperty.call(remainder.dataset, 'pageIndex')) {
            delete remainder.dataset.pageIndex;
        }
        let sibling = breakEl.nextSibling;
        let movedAny = false;
        while (sibling) {
            const next = sibling.nextSibling;
            remainder.appendChild(sibling);
            sibling = next;
            movedAny = true;
        }
        if (parent.parentElement) {
            parent.parentElement.insertBefore(remainder, parent.nextSibling);
        }
        main.insertBefore(breakEl, remainder);
        if (!movedAny) {
            if (typeof remainder.remove === 'function') {
                remainder.remove();
            } else if (remainder.parentElement) {
                remainder.parentElement.removeChild(remainder);
            }
        }
        pruneEmptyContainers(parent);
    }

    function normalizePageBreaks() {
        if (!main) return;
        const breaks = Array.from(main.querySelectorAll('.page-break'));
        breaks.forEach(el => {
            if (el.parentElement !== main) {
                promoteNestedPageBreak(el);
            }
        });
    }

    function splitPages() {
        pages = [];
        elementPageIndex = new WeakMap();
        if (!main) return;
        normalizePageBreaks();
        Array.from(main.children).forEach((el) => {
            if (el && el.dataset && "pageIndex" in el.dataset) {
                delete el.dataset.pageIndex;
            }
        });
        let currentPageContent = [];
        Array.from(main.children).forEach(el => {
            if (el.classList && el.classList.contains('page-break')) {
                registerPageContent(currentPageContent, pages.length);
                // flush current page, do not include the break element
                pages.push(currentPageContent);
                currentPageContent = [];
                return;
            }
            currentPageContent.push(el);
        });
        registerPageContent(currentPageContent, pages.length);
        pages.push(currentPageContent);
    }

    function setPaginationVisibility(visible) {
        paginationAreas.forEach(area => {
            if (!area.container) return;
            if (visible) {
                area.container.classList.add('is-active');
                area.container.removeAttribute('hidden');
            } else {
                area.container.classList.remove('is-active');
                area.container.setAttribute('hidden', '');
            }
        });
    }

    function updatePaginationUi(pageIndex) {
        const total = pages.length;
        const displayIndex = total > 0 ? pageIndex + 1 : 0;
        paginationAreas.forEach(area => {
            const infoText = vt('paginationInfo', displayIndex + ' / ' + total, {
                current: displayIndex,
                total: total,
            });
            area.pageInfo.textContent = infoText;
            area.prev.textContent = vt('prevPage', area.prev.textContent);
            area.next.textContent = vt('nextPage', area.next.textContent);
            area.prev.disabled = pageIndex === 0;
            area.next.disabled = pageIndex >= total - 1;
        });
    }

    function scrollViewerToTop() {
        const performScroll = () => {
            if (typeof window === 'undefined') return;
            if (typeof window.scrollTo === 'function') {
                try {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                } catch (err) {
                    window.scrollTo(0, 0);
                }
            } else if (typeof window.scroll === 'function') {
                window.scroll(0, 0);
            } else {
                if (document.body) {
                    document.body.scrollTop = 0;
                }
                if (document.documentElement) {
                    document.documentElement.scrollTop = 0;
                }
            }
        };
        if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(performScroll);
        } else {
            performScroll();
        }
    }

    function renderPage(pageIndex, options = {}) {
        const safeIndex = Math.max(0, Math.min(pageIndex, Math.max(pages.length - 1, 0)));
        Array.from(main.children).forEach(el => el.classList.add('page-hidden'));
        if (pages[safeIndex]) {
            pages[safeIndex].forEach(el => el.classList.remove('page-hidden'));
        }
        updatePaginationUi(safeIndex);
        currentPage = safeIndex;
        annotateLinks(main);
        if (options && options.scrollToTop) {
            scrollViewerToTop();
        }
    }

    const updateViewModeLabel = () => {
        if (!viewModeToggle) return;
        const label = isPaged
            ? vt('viewModeAll', viewModeToggle.textContent)
            : vt('viewModePaged', viewModeToggle.textContent);
        viewModeToggle.textContent = label;
        viewModeToggle.title = label;
        viewModeToggle.classList.toggle('active', isPaged);
    };

    if (viewModeToggle) {
        updateViewModeLabel();
        viewModeToggle.addEventListener('click', () => {
            isPaged = !isPaged;
            updateViewModeLabel();
            if (isPaged) {
                splitPages();
                setPaginationVisibility(true);
                renderPage(currentPage);
                if (window.location.hash) {
                    syncPageWithHash();
                }
            } else {
                setPaginationVisibility(false);
                Array.from(main.children).forEach(el => el.classList.remove('page-hidden'));
                annotateLinks(main);
            }
        });
    }

    const goPrev = () => {
        if (currentPage > 0) {
            renderPage(currentPage - 1, { scrollToTop: true });
        }
    };
    const goNext = () => {
        if (currentPage < pages.length - 1) {
            renderPage(currentPage + 1, { scrollToTop: true });
        }
    };

    paginationAreas.forEach(area => {
        area.prev.addEventListener('click', goPrev);
        area.next.addEventListener('click', goNext);
    });
    document.addEventListener('click', handleInternalNavigation);
    window.addEventListener('hashchange', syncPageWithHash);
    if (window.location.hash) {
        syncPageWithHash();
    }
    // Dialogue Style Logic
    function updateDialogueStyleLabel() {
        if (!dialogueStyleToggle) return;
        const label = isBubbleStyle
            ? vt('dialogueStyleBubble', dialogueStyleToggle.textContent)
            : vt('dialogueStyleQuote', dialogueStyleToggle.textContent);
        dialogueStyleToggle.textContent = label;
        dialogueStyleToggle.title = label;
        dialogueStyleToggle.classList.toggle('active', !isBubbleStyle);
    }

    if (dialogueStyleToggle) {
        updateDialogueStyleLabel();
        dialogueStyleToggle.addEventListener('click', () => {
            isBubbleStyle = !isBubbleStyle;
            const newStyle = isBubbleStyle ? 'bubble' : 'quote';
            main.querySelectorAll('.npc-dialogue').forEach((d) => {
                d.dataset.style = newStyle;
            });
            updateDialogueStyleLabel();
        });
    }
    if (expressionTagToggle) {
        updateExpressionTagLabel();
        expressionTagToggle.addEventListener('click', () => {
            isExpressionTagEnabled = !isExpressionTagEnabled;
            updateExpressionTagLabel();
        });
    }

    function updateRubyLabel() {
        if (!rubyToggle) return;
        const label = isRubyVisible
            ? vt('rubyVisible', rubyToggle.textContent)
            : vt('rubyHidden', rubyToggle.textContent);
        rubyToggle.textContent = label;
        rubyToggle.title = label;
        rubyToggle.classList.toggle('active', !isRubyVisible);
    }

    if (rubyToggle) {
        updateRubyLabel();
        rubyToggle.addEventListener('click', () => {
            isRubyVisible = !isRubyVisible;
            updateRubyLabel();
            body.classList.toggle('hide-ruby', !isRubyVisible);
        });
    }

    applyViewerLanguage(currentViewerLanguage, { persist: false });

    function convertRubySpansToElements(scope){
        if (!scope || !scope.querySelectorAll) return;
        var selector = 'span[data-ruby-reading]';
        var targets = [];
        if (scope.matches && scope.matches(selector)) targets.push(scope);
        scope.querySelectorAll(selector).forEach(function(span){
            targets.push(span);
        });
        targets.forEach(function(span){
            if (!span.parentNode) return;
            var ruby = document.createElement('ruby');
            while (span.firstChild) ruby.appendChild(span.firstChild);
            var reading = span.getAttribute('data-ruby-reading') || '';
            if (reading) {
                var rt = document.createElement('rt');
                rt.textContent = reading;
                ruby.appendChild(rt);
            }
            span.replaceWith(ruby);
        });
    }
    convertRubySpansToElements(main);

    function flattenRubyForPlainText(root, options = {}){
        const { includeReading = true } = options;
        if (!root) return;
        convertRubySpansToElements(root);
        root.querySelectorAll('ruby').forEach(ruby => {
            if (!ruby.parentNode) return;
            const baseClone = ruby.cloneNode(true);
            baseClone.querySelectorAll('rt, rp').forEach(node => node.remove());
            const baseText = baseClone.textContent || '';
            const readings = Array.from(ruby.querySelectorAll('rt'))
                .map(rt => (rt.textContent || '').trim())
                .filter(Boolean);
            const readingJoined = readings.join('ãƒ»');
            let replacementText = baseText;
            if (readingJoined && includeReading) {
                replacementText = (baseText || '') + 'ï¼ˆ' + readingJoined + 'ï¼‰';
                if (!baseText) replacementText = readingJoined;
            }
            ruby.parentNode.replaceChild(document.createTextNode(replacementText), ruby);
        });
    }

    function extractPlainTextForCopy(root){
        if (!root) return '';
        const doc = root.ownerDocument || document;
        const working = root.cloneNode(true);
        const TEXT_NODE_TYPE = typeof Node !== 'undefined' ? Node.TEXT_NODE : 3;
        const ELEMENT_NODE_TYPE =
            typeof Node !== 'undefined' ? Node.ELEMENT_NODE : 1;
        const collapseIndentationWhitespace = (node) => {
            if (!node || !doc) return;
            const preserveTags = new Set(['PRE', 'CODE', 'TEXTAREA']);
            const showText =
                typeof NodeFilter !== 'undefined'
                    ? NodeFilter.SHOW_TEXT
                    : 4;
            let walker;
            try {
                walker = doc.createTreeWalker(node, showText, null, false);
            } catch (_) {
                walker = null;
            }
            if (!walker) return;
            const toProcess = [];
            let current = walker.nextNode();
            while (current) {
                toProcess.push(current);
                current = walker.nextNode();
            }
            toProcess.forEach((textNode) => {
                if (!textNode || textNode.nodeType !== TEXT_NODE_TYPE) return;
                const parentEl =
                    textNode.parentElement ||
                    (textNode.parentNode &&
                    textNode.parentNode.nodeType === ELEMENT_NODE_TYPE
                        ? textNode.parentNode
                        : null);
                if (
                    parentEl &&
                    typeof parentEl.tagName === 'string' &&
                    preserveTags.has(parentEl.tagName.toUpperCase())
                ) {
                    return;
                }
                const value = textNode.nodeValue || '';
                if (!value) return;
                if (/^[\s\u00A0]+$/.test(value)) {
                    const newlineMatches = value.match(/\n/g);
                    if (newlineMatches && newlineMatches.length > 0) {
                        textNode.nodeValue = '\n'.repeat(newlineMatches.length);
                    } else {
                        textNode.remove();
                    }
                }
            });
        };
        collapseIndentationWhitespace(working);
        const blockSelectorList = [
            'p',
            'li',
            'blockquote',
            'pre',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            '.info-box',
            '.gm-memo',
            '.secret-box',
            '.handout-box',
            '.skill-box',
            '.npc-dialogue',
            '.npc-text',
            '.copy-target-export',
        ];
        const blockSelector =
            blockSelectorList.length > 0 ? blockSelectorList.join(',') : '';
        const addTrailingBreak = (el) => {
            if (!el) return;
            const target = el;
            const createBreak = () =>
                doc && typeof doc.createTextNode === 'function'
                    ? doc.createTextNode('\n')
                    : null;
            let lastChild = target.lastChild;
            if (!lastChild) {
                const node = createBreak();
                if (node) target.appendChild(node);
                return;
            }
            if (lastChild.nodeType !== TEXT_NODE_TYPE) {
                const node = createBreak();
                if (node) target.appendChild(node);
                return;
            }
            if (!/\n$/.test(lastChild.textContent || '')) {
                lastChild.textContent = (lastChild.textContent || '') + '\n';
            }
        };
        if (
            typeof working.querySelectorAll === 'function' &&
            doc &&
            typeof doc.createTextNode === 'function'
        ) {
            working.querySelectorAll('br').forEach((br) => {
                br.replaceWith(doc.createTextNode('\n'));
            });
            if (blockSelector.length > 0) {
                working.querySelectorAll(blockSelector).forEach((el) => {
                    addTrailingBreak(el);
                });
            }
        }
        if (
            working.nodeType === ELEMENT_NODE_TYPE &&
            typeof working.matches === 'function'
        ) {
            if (blockSelector.length > 0 && working.matches(blockSelector)) {
                addTrailingBreak(working);
            }
        }
        let text = '';
        try {
            if (doc && typeof doc.createRange === 'function') {
                const range = doc.createRange();
                range.selectNodeContents(working);
                text = range.toString();
            }
        } catch (_) {
            text = '';
        }
        if (!text) {
            text = working.textContent || '';
        }
        if (!text) return '';
        text = text.replace(/\r\n?/g, '\n');
        text = text.replace(/\u00A0/g, ' ');
        text = text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '');
        text = text.replace(/\n{3,}/g, '\n\n');
        text = text.replace(/[ \t]+\n/g, '\n');
        const hasWhitespaceSensitiveContent =
            (working.nodeType === ELEMENT_NODE_TYPE &&
                typeof working.matches === 'function' &&
                working.matches('pre, textarea')) ||
            (typeof working.querySelector === 'function' &&
                working.querySelector('pre, textarea'));
        if (!hasWhitespaceSensitiveContent) {
            const lines = text.split('\n');
            const normalized = lines.map(line => {
                if (!line) return line;
                return line.replace(/^[ \t]+/, '');
            });
            text = normalized.join('\n');
        }
        text = text.replace(/^\n+/, '').replace(/\n+$/, '');
        return text;
    }

    // Copy (HTML + text, with fallbacks)
    main.addEventListener('click', e => {
        if (!e.target.classList.contains('copy-btn-export')) return;
        const parent = e.target.parentElement;
        const cloneForHtml = parent.cloneNode(true);
        cloneForHtml.querySelectorAll('.copy-btn-export').forEach(b => b.remove());
        if (cloneForHtml.classList) {
            cloneForHtml.classList.remove('copy-target-export');
        }
        if (typeof cloneForHtml.removeAttribute === 'function') {
            cloneForHtml.removeAttribute('data-page-index');
        }
        cloneForHtml.querySelectorAll('[data-page-index]').forEach(node => {
            if (typeof node.removeAttribute === 'function') {
                node.removeAttribute('data-page-index');
            }
        });
        convertRubySpansToElements(cloneForHtml);
        let htmlToCopy = cloneForHtml.outerHTML || cloneForHtml.innerHTML || '';
        const cloneForText = cloneForHtml.cloneNode(true);
        const includeRubyReading = !body.classList.contains('hide-ruby');
        flattenRubyForPlainText(cloneForText, { includeReading: includeRubyReading });
        let textToCopy = '';
        if (parent.classList.contains('npc-dialogue')) {
            const textEl = cloneForText.querySelector('.npc-text');
            const content = textEl
                ? extractPlainTextForCopy(textEl)
                : extractPlainTextForCopy(cloneForText);
            let expressionSuffix = '';
            if (isExpressionTagEnabled) {
                const expressionName = getRegisteredExpressionName(parent);
                if (expressionName) {
                    expressionSuffix = '@' + expressionName;
                }
            }
            // Avoid nested template literals inside generated JS
            textToCopy = 'ã€Œ' + content + 'ã€' + (expressionSuffix || '');
        } else {
            textToCopy = extractPlainTextForCopy(cloneForText);
        }
        const plainClipboardText = textToCopy.replace(/\n/g, '\r\n');
        const successLabel = vt('copyButtonSuccess', 'Copied!');
        const showSuccess = () => {
            e.target.textContent = successLabel;
            setTimeout(() => {
                e.target.innerHTML = COPY_BTN_SVG;
            }, 1000);
        };
        if (navigator.clipboard && window.ClipboardItem) {
            const items = [new ClipboardItem({'text/plain': new Blob([plainClipboardText], {type:'text/plain'}), 'text/html': new Blob([htmlToCopy], {type:'text/html'})})];
            navigator.clipboard.write(items).then(showSuccess).catch(()=>fallbackCopy());
        } else { fallbackCopy(); }
        function fallbackCopy(){
            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                navigator.clipboard.writeText(plainClipboardText).then(showSuccess).catch(()=>legacyCopy());
                return;
            }
            legacyCopy();
        }
        function legacyCopy(){
            const container=document.createElement('div');
            container.style.position='fixed';
            container.style.left='-9999px';
            container.innerHTML=htmlToCopy;
            document.body.appendChild(container);
            const range=document.createRange();
            range.selectNodeContents(container);
            const sel=window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            document.execCommand('copy');
            sel.removeAllRanges();
            document.body.removeChild(container);
            showSuccess();
        }
    });
});
        